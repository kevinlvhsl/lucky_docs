[文章部分转载自:Vue 项目性能优化 — 实践指南](https://juejin.im/post/5d548b83f265da03ab42471d)

## 一、代码层面性能优化

### 1.1、v-if 和 v-show 区分使用场景

`v-if` 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

`v-show`  就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。

所以，**v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。**

### 1.2、 v-for 遍历必须为 item 添加 key，且避免同时使用 v-if

**（1）v-for 遍历必须为 item 添加 key**

在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。

**（2）v-for 遍历避免同时使用 v-if**

v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。

**推荐**

```js
<ul>
  <li
    v-for="user in activeUsers"
    :key="user.id">
    {{ user.name }}
  </li>
</ul>
computed: {
  activeUsers: function () {
    return this.users.filter(function (user) {
	 return user.isActive
    })
  }
}


```

### 1.3、长列表性能优化

Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 `Object.freeze`或者使用`Object.preventExtensions`方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。

[Object.freeze 和 Object.preventExtensions 介绍](https://segmentfault.com/a/1190000003894119)

```js
export default {
  data: () => ({
    users: {}
  }),
  async created() {
    const users = await axios.get("/api/users");
    this.users = Object.freeze(users);
  }
};
```

### 1.4、 事件的销毁

Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。 如果在 js 内使用 addEventListener 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如：

```js
created() {
  addEventListener('click', this.click, false);
  //定时器
  timer=setInternal(()=>{
      ....
  },1000)
},
beforeDestroy() {
  removeEventListener('click', this.click, false);
  clearInternal(timer);//记得清理定时器
}

```

### 1.5、 图片资源懒加载

对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 `vue-lazyload` 插件：

[vue-lazyload 地址](https://github.com/hilongjw/vue-lazyload)

```js
import Vue from "vue";
import App from "./App.vue";
import VueLazyload from "vue-lazyload";

Vue.use(VueLazyload);

// or with options
Vue.use(VueLazyload, {
  preLoad: 1.3,
  error: "dist/error.png",
  loading: "dist/loading.gif",
  attempt: 1
});

new Vue({
  el: "body",
  components: {
    App
  }
});
//使用
<ul>
  <li v-for="img in list">
    <img v-lazy="img.src" >
  </li>
</ul>
```

### 1.6、 路由懒加载

Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。

```js
const Foo = () => import("./Foo.vue");
const router = new VueRouter({
  routes: [{ path: "/foo", component: Foo }]
});
```

### 1.7、 第三方插件的按需引入

我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 `plugin-syntax-dynamic-import` ，然后可以只引入需要的组件，以达到减小项目体积的目的。此处以引入 `ant-design` 和 `iview` 为例

**(1)安装**

```bash
npm install --save-dev @babel/plugin-syntax-dynamic-import
```

**(2)babel.config.js**

```js
module.exports = {
  presets: [
    [
      "@babel/preset-env",
      {
        targets: {
          browsers: ["last 3 versions", "ie>=9"]
        },
        useBuiltIns: "entry",
        debug: false
      }
    ],
    "@vue/babel-preset-jsx"
  ],
  plugins: [
    "@babel/plugin-transform-runtime",
    "@babel/plugin-syntax-dynamic-import",
    "transform-vue-jsx",
    [
      "import",
      {
        libraryName: "ant-design-vue",
        libraryDirectory: "es",
        style: "css"
      },
      "ant-design-vue"
    ],
    [
      "import",
      {
        libraryName: "iview",
        libraryDirectory: "src/components"
      }
    ]
  ]
};
```

**(3)组件中使用**

```js
import { Button } from "iview";
```

### 1.8、 优化无限列表性能

如果你的应用存在非常长或者无限滚动的列表，那么需要采用   窗口化   的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。 你可以参考以下开源项目 [vue-virtual-scroll-list](https://github.com/tangbc/vue-virtual-scroll-list)  和  [vue-virtual-scroller](https://github.com/Akryum/vue-virtual-scroller) 来优化这种无限列表的场景的。

### 1.9、 时间分片渲染大量数据

众所周知，页面的卡顿是由于同时渲染大量 DOM 所引起的，所以我们考虑将渲染过程分批进行。常见的分批渲染使用`setTimeout`,`requestAnimationFrame`和`DocumentFragment`

```html
<ul id="container"></ul>
```

**(1) 使用 setTimeout 分片**

```js
//需要插入的容器
let ul = document.getElementById("container");
// 插入十万条数据
let total = 100000;
// 一次插入 20 条
let once = 20;
//总页数
let page = total / once;
//每条记录的索引
let index = 0;
//循环加载数据
function loop(curTotal, curIndex) {
  if (curTotal <= 0) {
    return false;
  }
  //每页多少条
  let pageCount = Math.min(curTotal, once);
  setTimeout(() => {
    for (let i = 0; i < pageCount; i++) {
      let li = document.createElement("li");
      li.innerText = curIndex + i + " : " + ~~(Math.random() * total);
      ul.appendChild(li);
    }
    loop(curTotal - pageCount, curIndex + pageCount);
  }, 0);
}
loop(total, index);
```

> 使用 setTimeout 你会发现明显的闪屏现象，其主要原因如下：

- setTimeout 的执行时间并不是确定的。在 JS 中，setTimeout 任务被放进事件队列中，只有主线程执行完才会去检查事件队列中的任务是否需要执行，因此 setTimeout 的实际执行时间可能会比其设定的时间晚一些。
- 刷新频率受屏幕分辨率和屏幕尺寸的影响，因此不同设备的刷新频率可能会不同，而 setTimeout 只能设置一个固定时间间隔，这个时间不一定和屏幕的刷新时间相同。

**(2) 使用 requestAnimationFrame**

> 与 setTimeout 相比，requestAnimationFrame 最大的优势是由系统来决定回调函数的执行时机。如果屏幕刷新率是 60Hz,那么回调函数就每 16.7ms 被执行一次，如果刷新率是 75Hz，那么这个时间间隔就变成了 1000/75=13.3ms，换句话说就是，requestAnimationFrame 的步伐跟着系统的刷新步伐走。它能保证回调函数在屏幕每一次的刷新间隔中只被执行一次，这样就不会引起丢帧现象

```js
//需要插入的容器
let ul = document.getElementById("container");
// 插入十万条数据
let total = 100000;
// 一次插入 20 条
let once = 20;
//总页数
let page = total / once;
//每条记录的索引
let index = 0;
//循环加载数据
function loop(curTotal, curIndex) {
  if (curTotal <= 0) {
    return false;
  }
  //每页多少条
  let pageCount = Math.min(curTotal, once);
  window.requestAnimationFrame(function() {
    for (let i = 0; i < pageCount; i++) {
      let li = document.createElement("li");
      li.innerText = curIndex + i + " : " + ~~(Math.random() * total);
      ul.appendChild(li);
    }
    loop(curTotal - pageCount, curIndex + pageCount);
  });
}
loop(total, index);
```

[此例参考自：「中高级前端」高性能渲染十万条数据（时间分片）](https://juejin.im/post/5d76f469f265da039a28aff7)

**(3) 使用 DocumentFragment**

从 MDN 的说明中，我们得知 DocumentFragments 是 DOM 节点，但并不是 DOM 树的一部分，可以认为是存在内存中的，所以将子元素插入到文档片段时不会引起页面回流。

```js
//需要插入的容器
let ul = document.getElementById("container");
// 插入十万条数据
let total = 100000;
// 一次插入 20 条
let once = 20;
//总页数
let page = total / once;
//每条记录的索引
let index = 0;
//循环加载数据
function loop(curTotal, curIndex) {
  if (curTotal <= 0) {
    return false;
  }
  //每页多少条
  let pageCount = Math.min(curTotal, once);
  window.requestAnimationFrame(function() {
    let fragment = document.createDocumentFragment();
    for (let i = 0; i < pageCount; i++) {
      let li = document.createElement("li");
      li.innerText = curIndex + i + " : " + ~~(Math.random() * total);
      fragment.appendChild(li);
    }
    ul.appendChild(fragment);
    loop(curTotal - pageCount, curIndex + pageCount);
  });
}
loop(total, index);
```

### 1.10、服务端渲染 SSR or 预渲染

服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。

**（1）服务端渲染的优点：**

- **更好的 SEO**： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；

* **更快的内容到达时间（首屏加载更快）**： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；

**（2）服务端渲染的缺点：**

- **更多的开发条件限制**： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，`需要处于 Node.js server 运行环境`；

* **更多的服务器负载**：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。

### 1.11、 处理大量数据使用 Web Woker

Web Worker 通常应用于哪些方面呢？

- 处理密集型数学计算
- 大数据集排序
- 数据处理（压缩、音频分析、图像处理等）
- 高流量网络通信

**(1)、Work 创建及终止**

**实例化**

```js
//1. 实例化woker,
var w1 = new Worker("http://some.url.1/mycoolworker.js");
```

- 这个 URL 应该`指向一个 JavaScript 文件的位置（`而不是一个 HTML 页面！），这个文件将被加载到一个 Worker 中。然后浏览器`启动一个独立的线程`，让这个文件在这个线程中作为独立的程序运行。

- **如果浏览器中有两个或多个页面（或同一页上的多个 tab ！）试图从同一个文件 URL 创建 Worker，那么最终得到的实际上是完全独立的 Worker**

**(2)、数据收发**

> `Worke`r 之间以及它们和`主程序之间，`不会共享任何作用域或资源`，那会把所有多线程编程的噩梦带到前端领域，而是`通过`一个`基本的事件消息机制相互联系`;

```js
//2. 数据的获取（主线程发送消息给woker）
w1.addEventListener("message", function(evt) {
  // evt.data
});

//数据的发送(主线程收到woker的信息)
w1.postMessage("something cool to say");

// mydemo_woker.js
//在worker内部，监听主线程发给自己的信息
addEventListener("message", function(evt) {
  // evt.data
});
//发送数据给主线程
postMessage("a really cool reply");
```

**注意，专用 Worker 和创建它的程序之间是一对一的关系。**

> 通常由`主页面`应用程序`创建 Worke`r，但`若是需要`的话，`Worker` 也可以`实例化`它自己的`子 Worker`，称为 subworker。有时候，把这样的细节委托给一个“主”Worker，由它来创建其他 Worker 处理部分任务，这样很有用。`不幸的是`，到写作本书时为
> 止，`Chrome 还不支持 subworker`，不过 Firefox 支持。

**(3)、Work 的终止**

```js
//主页面手动终止
w1.terminate();
```

> 突然终止 Worker 线程不会给它任何机会完成它的工作或者清理任何资源。这就类似于通过关闭浏览器标签页来关闭页面。

**(4)、Work 运行环境及外部脚本加载**

> **Work 不可以访问主程序的任何资源，不能访问 dom 或者其他资源，但是可以执行网络操 作（Ajax、WebSockets）以及设定定时 器。还 有，Worker 可以访问几个重要的全局变量和功能的本地复 本，包括 navigator 、location 、JSON 和 applicationCache**

**可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本：**

```js
// 在Worker内部
importScripts("foo.js", "bar.js");
```

**这些脚本加载是同步的。也就是说，importScripts(..) 调用会阻塞余下 Worker 的执行，直到文件加载和执行完成。**

### 1.12、 减少重绘和回流

`重绘`就是在不影响排版的情况下对这个元素重新绘制的过程。例如改变一个元素的背景颜色、字体颜色等。

`回流`：当 render tree 中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。

**常见的触发重绘和回流的情况：**

- 添加、删除元素（回流+重绘）
- 隐藏元素，display:none(回流+重绘)，visibility:hidden(只重绘，不回流)
- 移动元素，比如改变 top、left（jquery 的 animate 方法就是改变 top、left 不一定会影响回流），或者移动元素到另外 1 个父元素中。(重绘+回流)
- 对 style 的操作（对不同的属性操作，影响不一样）（color、background-color）=>(重绘) (padding、margin)=>(回流)
- 浏览器大小改变 resize、font-size（重绘+回流）
- transform/opacity （不会触发生重绘、回流）
- 最复杂的一种：获取某些属性，引发回流 很多浏览器会对回流做优化，他会等到足够数量的变化发生，在做一次批处理回流。 但是除了 render 树的直接变化。 当获取一些属性时，浏览器为了获得正确的值也会触发回流。
  - offsetTop, offsetLeft, offsetWidth, offsetHeight
  - scrollTop/Left/Width/Height
  - clientTop/Left/Width/Height
  - width,height
  - 调用了 getComputedStyle(), 或者 IE 的 currentStyle

::: tip
减少重绘和回流方案:

- **避免逐项更改样式**。最好一次性更改 style 属性，或者将样式列表定义为 class 并一次性更改 class 属性。
- **避免循环操作 DOM**。创建一个 documentFragment 或 div，在它上面应用所有 DOM 操作，最后再把它添加到 window.document。
- **避免多次读取 offsetLeft 等属性**。无法避免则将它们缓存到变量。
- **将复杂的元素绝对定位或固定定位，使它脱离文档流**。否则回流代价十分高
- **不要使用 table 布局**，可能很小的一个小改动会造成整个 table 的重新布局
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame
- CSS 选择符从右往左匹配查找，**避免 DOM 深度过深**
- **使用 visibility 替换 display: none** ，因为前者只会引起重绘，后者会引发回流（改变了布局）
- **使用 translate 替代 top**
- 把 DOM 离线后修改，比如：先把 DOM 给 display:none (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来
- **使用 flexbox 替代老的布局模型**
  。
  :::

### 1.13、 函数防抖和节流

**防抖（debounce）**

> 所谓防抖，就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。

```js
function debounce(func, wait) {
  let timeout;
  return function() {
    let context = this;
    let args = arguments;
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}
```

**节流（throttle）**

> 所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数

```js
function throttle(func, wait) {
  let timeout;
  return function() {
    let context = this;
    let args = arguments;
    if (!timeout) {
      timeout = setTimeout(() => {
        timeout = null;
        func.apply(context, args);
      }, wait);
    }
  };
}
```

### 1.14、SystemJS 动态加载 js

[systemjs](https://github.com/systemjs/systemjs)可以结合 vue 的动态组件实现，vue 组件动态化，本地代码最小化。

```js
<script src="./system.js"> </script>
<script>
SystemJS.import("onejs").then(function(m) {
  Vue.component("component-name",m.default)
});
</script>
```

### 1.15、 页面预加载 preload

详情请见：[页面预加载 preload](../deep/页面预加载.md);

## 二、前端性能清单

### 目录

1. **[HTML](#html)**
2. **[CSS](#css)**
3. **[Fonts](#fonts)**
4. **[Images](#images)**
5. **[JavaScript](#javascript)**
6. **[Server](#server) (梳理中)**
7. **[JS Frameworks](#js-frameworks) (梳理中)**

### 概述

性能是一个很大的主题，但它并不总是一个“后端”或“管理（admin）”所要考虑的主题：它也是一个前端需要考虑的。作为前端开发人员，前端性能清单是你在项目中应该检查或者至少需要注意的性能要点的详尽列表。

#### 如何使用?

对于每个规则，将有一个段落解释**为什么**此规则很重要以及**如何**解决它。有关更深入的信息，可相应找到可指向的 🛠 工具，📖 文章或 📹 媒体的链接，以便梳理。

前端性能清单中的所有项目都是获得最高性能得分的基本要素，但是你可以找到一些指标来帮助你最终确定一些规则的优先顺序。以下有 3 个级别的优先级：

- ![low](https://img.shields.io/badge/-low-green)[low] 表示该项目的优先级**较低**，对项目有影响。
- ![medium](https://img.shields.io/badge/-medium-orange)[medium] 表示该项目具有**中等优先级**并对项目产生影响，开发时需要处理这些项目。
- ![high](https://img.shields.io/badge/-high-red)[high] 表示该项目具有**高优先级**并对项目产生影响，开发时必须要处理这些项目，不然性能将大打折扣。

#### 性能测试工具

以下是一些您可以用来测试或监控您的网站或应用程序的工具：

- 🛠 [WebPagetest - Website Performance and Optimization Test](https://www.webpagetest.org/)
- 🛠 ☆ [Dareboost: Website Speed Test and Website Analysis](https://www.dareboost.com/) (use the coupon WPCDD20 for -20%)
- 🛠 [GTmetrix | Website Speed and Performance Optimization](https://gtmetrix.com/)
- 🛠 [PageSpeed Insights](https://developers.google.com/speed/pagespeed/insights/)
- 🛠 [Web.dev](https://web.dev/measure)
- 🛠 [Pingdom Website Speed Test](https://tools.pingdom.com)
- 📖 [Pagespeed - The tool and optimization guide](https://varvy.com/pagespeed/)
- 📖 [Make the Web Faster | Google Developers](https://developers.google.com/speed/)
- 🛠 [Sitespeed.io - Welcome to the wonderful world of Web Performance](https://www.sitespeed.io/)
- 🛠 [Calibre](https://calibreapp.com/)
- 🛠 [Website Speed Test | Check Web Performance &raquo; Dotcom-Tools](https://www.dotcom-tools.com/website-speed-test.aspx)
- 🛠 [Website and Server Uptime Monitoring - Pingdom](https://www.pingdom.com/product/uptime-monitoring/) ([Free Signup Link](https://www.pingdom.com/free))
- 🛠 [Uptime Robot](https://uptimerobot.com)
- 🛠 [SpeedCurve: Monitor front-end performance](https://speedcurve.com)
- 🛠 [PWMetrics - CLI tool and lib to gather performance metrics](https://github.com/paulirish/pwmetrics)
- 🛠 [Varvy - Page speed optimization](https://varvy.com/pagespeed/)
- 🛠 [Lighthouse - Google](https://developers.google.com/web/tools/lighthouse/#devtools)
- 🛠 [Checkbot browser extension - Checks for web performance best practices](https://www.checkbot.io/)
- 🛠 [Yellow Lab Tools | Online test to help speeding up heavy web pages](https://yellowlab.tools/)
- 🛠 [Speedrank - Web Performance Monitoring](https://speedrank.app/)
- 🛠 [DebugBear - Monitor website performance and Lighthouse scores](https://www.debugbear.com/)

#### 参考

- 📖 [The Cost Of JavaScript - YouTube](https://www.youtube.com/watch?v=_bzqF05xsC4)
- 📖 [AddyOsmani.com - Start Performance Budgeting](https://addyosmani.com/blog/performance-budgets/)
- 📖 [Get Started With Analyzing Runtime Performance  |  Google Developers](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/)
- 📖 [State of the Web | 2018_01_01](https://httparchive.org/reports/state-of-the-web?start=2018_01_01)
- 📖 [Page Weight Doesn't Matter](https://www.speedshop.co/2015/11/05/page-weight-doesnt-matter.html)
- 📖 [Front-End Performance Checklist 2018 [PDF, Apple Pages]](https://www.smashingmagazine.com/2018/01/front-end-performance-checklist-2018-pdf-pages/)
- 📖 [Designing for Performance Weighing Aesthetics and Speed - By Lara Callender Hogan [eBook, Print]](http://designingforperformance.com/index.html)
- 📖 [Varvy - Web performance glossary](https://varvy.com/performance/)
- 📖 [fabkrum/web-performance-resources: Up to date collection of valuable web performance resources](https://github.com/fabkrum/web-performance-resources)
- 📖 [Checkbot - Web Speed Best Practices](https://www.checkbot.io/guide/speed/)
- 🛠 [Progressive Tooling - A list of community-built, third-party tools that can be used to improve page performance](https://progressivetooling.com/)

---

### HTML

![html](/html.png)

- [ ] **压缩 HTML:** ![medium](https://img.shields.io/badge/-medium-orange) HTML 代码压缩，将注释、空格和新行从生产文件中删除。

_为什么：_

> 删除所有不必要的空格、注释和中断行将减少 HTML 的大小，加快网站的页面加载时间，并显著减少用户的下载时间。

_怎么做：_

> 大多数框架都有插件用来压缩网页的体积。你可以使用一组可以自动完成工作的 NPM 模块。

- 🛠 [HTML minifier | Minify Code](http://minifycode.com/html-minifier/)
- 📖 [Experimenting with HTML minifier — Perfection Kills](http://perfectionkills.com/experimenting-with-html-minifier/#use_short_doctype)

- [ ] **删除不必要的注释：** ![low](https://img.shields.io/badge/-low-green) 确保从您的网页中删除注释。

_为什么：_

> 注释对用户来说是没有用的，应该从生产环境文件中删除。可能需要保留注释的一种情况是：保留远端代码库（keep the origin for a library）。

_怎么做：_

> 大多数情况下，可以使用 HTML minify 插件删除注释。

- 🛠 [remove-html-comments - npm](https://www.npmjs.com/package/remove-html-comments)

* [ ] **删除不必要的属性：** ![low](https://img.shields.io/badge/-low-green) 像 `type="text/javascript"` or `type="text/css"` 这样的属性应该被移除。

```html
<!-- Before HTML5 -->
<script type="text/javascript">
  // Javascript code
</script>

<!-- Today -->
<script>
  // Javascript code
</script>
```

_为什么_

> 类型属性不是必需的，因为 HTML5 把 text/css 和 text/javascript 作为默认值。没用的代码应在网站或应用程序中删除，因为它们会使网页体积增大。

_怎么做：_

> ⁃ `确保所有`<link/>`和`<script></script>`标记都没有任何 type 属性。

- 📖 [The Script Tag | CSS-Tricks](https://css-tricks.com/the-script-tag/)

- [ ] **在 JavaScript 引用之前引用 CSS 标记：** ![high](https://img.shields.io/badge/-high-red) 确保在使用 JavaScript 代码之前加载 CSS。

  ```html
  <!-- 不推荐 -->
  <script src="jquery.js"></script>
  <script src="foo.js"></script>
  <link rel="stylesheet" href="foo.css" />

  <!-- 推荐 -->
  <link rel="stylesheet" href="foo.css" />
  <script src="jquery.js"></script>
  <script src="foo.js"></script>
  ```

  _为什么：_

  > 在引用 JavaScript 之前引用 CSS 可以实现更好地并行下载，从而加快浏览器的渲染速度。

  _怎么做：_

  > 确保`<head>`中的`<link/>`和`<style/>`始终位于`<script/>`之前。

  - 📖 [合理安排 styles 和 scripts 来提高网页速度](https://varvy.com/pagespeed/style-script-order.html)

- [ ] **最小化 iframe 的数量：** ![high](https://img.shields.io/badge/-high-red) 仅在没有任何其他技术可行性时才使用 iframe。尽量避免使用 iframe。

- [ ] **DNS 预取：** ![high](https://img.shields.io/badge/-high-red) 一次 DNS 查询时间大概在 60-120ms 之间或者更长，提前解析网页中可能的网络连接域名
  ```html
  <link rel="dns-prefetch" href="http://example.com/" />
  ```

**[⬆ 返回顶部](#table-of-contents)**

### CSS

![css](/css.png)

- [ ] **压缩:** ![high](https://img.shields.io/badge/-high-red) 所有 CSS 文件都需要被压缩，从生产文件中删除注释，空格和空行。

  _为什么：_

  > 缩小 CSS 文件后，内容加载速度更快，并且将更少的数据发送到客户端，所以在生产中缩小 CSS 文件是非常重要，这对用户是有益的，就像任何企业想要降低带宽成本和降低资源。

  _怎么做：_

  > 使用工具在构建或部署之前自动压缩文件。

  - 🛠 [cssnano: 基于 PostCSS 生态系统的模块化压缩工具。](https://cssnano.co/)
  - 🛠 [@neutrinojs/style-minify - npm](https://www.npmjs.com/package/@neutrinojs/style-minify)
  - 🛠 [Online CSS Compressor](http://refresh-sf.com)

- [ ] **Concatenation:** ![medium](https://img.shields.io/badge/-medium-orange) CSS 文件合并（对于 HTTP/2 效果不是很大）。

  ```html
  <!-- 不推荐 -->
  <link rel="stylesheet" src="foo.css" />
  <link rel="stylesheet" src="ajax.css" />

  <!-- 推荐 -->
  <link rel="stylesheet" src="combined.css" />
  ```

  _为什么：_

  > 如果你还在使用 HTTP/1，那么你就需要合并你的文件。不过在使用 HTTP/2 的情况下不用这样（效果待测试）。

  _怎么做：_

  > 在构建或部署之前使用在线工具或者其他插件来合并文件。
  > 当然，要确保合并文件后项目可以正常运行。

  - 📖 [HTTP: 优化应用程序交付 - 高性能浏览器网络 (O'Reilly)](https://hpbn.co/optimizing-application-delivery/#optimizing-for-http2)
  - 📖 [HTTP/2 时代的性能最佳实践](https://deliciousbrains.com/performance-best-practices-http2/)

- [ ] **非阻塞：** ![high](https://img.shields.io/badge/-high-red) CSS 文件需要非阻塞引入，以防止 DOM 花费更多时间才能渲染完成。

  ```html
  <link rel="preload" href="global.min.css" as="style" onload="this.rel='stylesheet'" />
  <noscript><link rel="stylesheet" href="global.min.css"/></noscript>
  ```

  _为什么：_

  > CSS 文件可以阻止页面加载并延迟页面呈现。使用`preload`实际上可以在浏览器开始显示页面内容之前加载 CSS 文件。

  _怎么做：_

  > 需要添加`rel`属性并赋值`preload`，并在`<link>`元素上添加`as=“style”`。

  - 📖 [loadCSS by filament group](https://github.com/filamentgroup/loadCSS)
  - 📖 [使用 loadCSS 预加载 CSS 的示例](https://gist.github.com/thedaviddias/c24763b82b9991e53928e66a0bafc9bf)
  - 📖 [使用 rel =“preload”预加载内容](https://developer.mozilla.org/en-US/docs/Web/HTML/Preloading_content)
  - 📖 [Preload: What Is It Good For? — Smashing Magazine](https://www.smashingmagazine.com/2016/02/preload-what-is-it-good-for/)

- [ ] **CSS 类(class)的长度:** ![low](https://img.shields.io/badge/-low-green) class 的长度会对 HTML 和 CSS 文件产生（轻微）影响。

  _为什么：_

  > 甚至性能影响也是有争议的，项目的命名策略会对样式表的可维护性有重大影响。如果使用 BEM，在某些情况下可能会写出比所需要的类名更长的字符。重要的是要明智的选择名字和命名空间。

  _怎么做：_

  > 可能有些人更关注类名的长度，但是网站按组件进行划分的话可以帮助减少类名的数量和长度。

  - 🛠 [long vs short class · jsPerf](https://jsperf.com/long-vs-short-class)

- [ ] **不用的 CSS:** ![medium](https://img.shields.io/badge/-medium-orange) 删除未使用的 CSS 选择器。

  _为什么：_

  > 删除未使用的 CSS 选择器可以减小文件的大小，提高资源的加载速度。

  _怎么做：_

  > ⚠️ 检查要使用的 CSS 框架是否已包含 reset/normalize 代码，可能不需要用到 reset/normalize 文件中的内容。

  - 🛠 [UnCSS Online](https://uncss-online.com/)
  - 🛠 [PurifyCSS](https://github.com/purifycss/purifycss)
  - 🛠 [PurgeCSS](https://github.com/FullHuman/purgecss)
  - 🛠 [Chrome DevTools Coverage](https://developers.google.com/web/updates/2017/04/devtools-release-notes#coverage)

* [ ] **关键 CSS（Critical）:** ![high](https://img.shields.io/badge/-high-red) 将页面渲染时必备的 CSS 通过`<style></style>`的方式内联到页面中（尽可能压缩后引用）。

  _为什么：_

  > 内联关键 CSS 有助于加速网页的呈现，减少对服务器的请求数量。

  _怎么做：_

  > 使用在线工具或使用 Addy Osmani 开发的插件生成关键 CSS。

  - 📖 [理解关键 CSS](https://www.smashingmagazine.com/2015/08/understanding-critical-css/)
  - 🛠 [Critical by Addy Osmani on GitHub](https://github.com/addyosmani/critical) automates this.
  - 📖 [Inlining critical CSS for better web performance | Go Make Things](https://gomakethings.com/inlining-critical-css-for-better-web-performance/)
  - 📖 [Critical Path CSS Generator - Prioritize above the fold content :: SiteLocity](https://www.sitelocity.com/critical-path-css-generator)
  - 📖 [Reduce the size of the above-the-fold content](https://developers.google.com/speed/docs/insights/PrioritizeVisibleContent)

- [ ] **嵌入或内联 CSS：** ![high](https://img.shields.io/badge/-high-red) 避免在`<body>`中使用嵌入或内联 CSS*（对 HTTP/2 无效）*

  _为什么：_

  > 因为将内容与设计分开是一种很好的做法。它还可以提高代码的可维护性并使站点可访问性更强。对于性能来说，它只是减少了 HTML 页面的文件大小和加载时间。

  _怎么做：_

  > 始终使用外部样式表或在`<head/>`中嵌入 CSS（并遵循其他 CSS 性能规则）。

  - 📖 [Observe CSS Best Practices: Avoid CSS Inline Styles](https://www.lifewire.com/avoid-inline-styles-for-css-3466846)

- [ ] **分析样式表的复杂性：** ![high](https://img.shields.io/badge/-high-red) 分析样式表有助于发现有问题的、冗余和重复的 CSS 选择器。

  _为什么：_

  > 有时在 CSS 中会出现冗余或验证错误，分析 CSS 文件并删除这些复杂性的代码可以加速 CSS 文件的读取和加载（因为您的浏览器会更快地读取它们）

  _怎么做：_

  > CSS 需要有编写规范，再通过 CSS 预处理器处理。下面列出的一些在线工具也可以帮助你分析和更正你的代码。

  - 🛠 [TestMyCSS | 优化和检查 CSS 性能](http://www.testmycss.com/)
  - 📖 [CSS 统计数据（stats）](https://cssstats.com/)
  - 🛠 [macbre/analyze-css: CSS 选择器复杂性和性能分析](https://github.com/macbre/analyze-css)
  - 🛠 [Project Wallace](https://www.projectwallace.com/) is like CSS Stats but stores stats over time so you can track your changes

**[⬆ 返回顶部](#table-of-contents)**

### 字体

![fonts](/fonts.png)

- 📖 [A Book Apart, Webfont Handbook](https://abookapart.com/products/webfont-handbook)

* [ ] **Webfont 格式：** ![medium](https://img.shields.io/badge/-medium-orange) 在你的网站或者应用使用 WOFF2 格式字体。

  _为什么：_

  > 根据 Google 的说法，WOFF 2.0 Web 字体压缩格式平均比 WOFF 1.0 高 30％的增益。一个较好的做法是使用 WOFF 2.0 作为主要字体，WOFF 1.0 和 TTF 格式字体作为备选。

  _怎么做：_

  > 在购买新字体之前应先检查提供商是否提供了 WOFF2 格式。如果使用的是免费字体，则可以始终使用 Font Squirrel 生成所需格式的字体。

  - 📖 [WOFF 2.0 – 了解有关下一代 Web 字体格式的更多信息，并将 TTF 转换为 WOFF2](https://gist.github.com/sergejmueller/cf6b4f2133bcb3e2f64a)
  - 🛠 [创建你自己的@ font-face Kits » Font Squirrel](https://www.fontsquirrel.com/tools/webfont-generator)
  - 🛠 [IcoMoon App - Icon Font, SVG, PDF & PNG Generator](https://icomoon.io/app/)
  - 📖 [Using @font-face | CSS-Tricks](https://css-tricks.com/snippets/css/using-font-face/?ref=frontendchecklist)
  - 📖 [Can I use... WOFF2](https://caniuse.com/#feat=woff2)

* [ ] **使用`preconnect`可以更快地加载字体：** ![medium](https://img.shields.io/badge/-medium-orange)

  ```html
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  ```

  _为什么：_

  > 当你浏览网站时，设备需要获取网站所在的位置以及需要连接的服务器。浏览器必须连接 DNS 服务器并等待查找完成后再获取资源（字体，CSS 文件...），`prefetche`和`preconnect`允许浏览器在空闲时进行上面的操作，在真实请求时就不需要再花时间去做一系列动作。这带来了性能的提升，因为当浏览器使用字体信息解析 css 文件并切从服务器请求字体文件时，它已经预先解析了 DNS 信息并且在其连接池中准备好与服务器的开放连接。

  _怎么做：_

  > 在预取您的网络字体之前，请使用网页测试来检测网站.
  > 查找蓝绿色 DNS 查找并记下正在请求的主机（Look for teal colored DNS lookups and note the host that are being requested.）
  > 在`<head/>`中添加预取的 webfonts，添加上一步查找到的主机名。

  - 📖 [Faster Google Fonts with Preconnect - CDN Planet](https://www.cdnplanet.com/blog/faster-google-webfonts-preconnect/)
  - 📖 [Make Your Site Faster with Preconnect Hints | Viget](https://www.viget.com/articles/make-your-site-faster-with-preconnect-hints/)
  - 📖 [Ultimate Guide to Browser Hints: Preload, Prefetch, and Preconnect - MachMetrics Speed Blog](https://www.machmetrics.com/speed-blog/guide-to-browser-hints-preload-preconnect-prefetch/)
  - 📖 [A Comprehensive Guide to Font Loading Strategies—zachleat.com](https://www.zachleat.com/web/comprehensive-webfonts/#font-face)
  - 🛠 [typekit/webfontloader: Web Font Loader gives you added control when using linked fonts via @font-face.](https://github.com/typekit/webfontloader)

* [ ] **Webfont 大小：** ![medium](https://img.shields.io/badge/-medium-orange) Webfont 尺寸不超过 300kb（包括所有变体）

- 📖 [Font Bytes - Page Weight](https://httparchive.org/reports/page-weight#bytesFont)

**[⬆ 返回顶部](#table-of-contents)**

### 图片

![images](/images.png)

- 📖 [Image Bytes in 2018](https://httparchive.org/reports/page-weight#bytesImg)

- [ ] **图像优化:** ![high](https://img.shields.io/badge/-high-red) 在保证压缩后的图片符合产品要求的情况下将图像进行优化。

  _为什么：_

  > 优化的图像在浏览器中加载速度更快，消耗的数据更少。

  _怎么做：_

  > 尽可能尝试使用 CSS3 效果（而不是用小图像替代）
  > 尽可能使用字体图片
  > 使用 SVG
  > 使用编译工具并指定 85 以下的级别压缩。

  - 📖 [Image Optimization | Web Fundamentals | Google Developers](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/image-optimization)
  - 📖 [Essential Image Optimization - An eBook by Addy Osmani](https://images.guide/)
  - 🛠 [TinyJPG – Compress JPEG images intelligently](https://tinyjpg.com/)
  - 🛠 [Kraken.io - Online Image Optimizer](https://kraken.io/web-interface)
  - 🛠 [Compressor.io - optimize and compress JPEG photos and PNG images](https://compressor.io/compress)
  - 🛠 [Cloudinary - Image Analysis Tool](https://webspeedtest.cloudinary.com)
  - 🛠 [SVGOMG - Optimize SVG vector graphics files](https://jakearchibald.github.io/svgomg/)

* [ ] **图像格式：** ![high](https://img.shields.io/badge/-high-red) 适当选择图像格式。

  _为什么：_

  > 确保图片不会减慢网站速度

  _怎么做：_

  > 使用[Lighthouse](https://developers.google.com/web/tools/lighthouse/)识别哪些图像可以使用下一代图片格式（如 JPEG 2000m JPEG XR 或 WebP）。
  > 比较不同的格式，有时使用 PNG8 比 PNG16 好，有时候不是。

  - 📖 [Serve Images in Next-Gen Formats  |  Tools for Web Developers  |  Google Developers](https://developers.google.com/web/tools/lighthouse/audits/webp)
  - 📖 [What Is the Right Image Format for Your Website? — SitePoint](https://www.sitepoint.com/what-is-the-right-image-format-for-your-website/)
  - 📖 [PNG8 - The Clear Winner — SitePoint](https://www.sitepoint.com/png8-the-clear-winner/)
  - 📖 [8-bit vs 16-bit - What Color Depth You Should Use And Why It Matters - DIY Photography](https://www.diyphotography.net/8-bit-vs-16-bit-color-depth-use-matters/)

- [ ] **使用矢量图像 VS 栅格/位图：** ![medium](https://img.shields.io/badge/-medium-orange) 可以的话，推荐使用矢量图像而不是位图图像。

  _为什么：_

  > 矢量图像（SVG）往往比图像小，具有响应性和完美缩放功能。而且这些图像可以通过 CSS 进行动画和修改操作。

* [ ] **图像尺寸：** ![medium](https://img.shields.io/badge/-medium-orange) 如果已知最终渲染图像大小，请在<img>上设置宽度和高度属性。

  _为什么：_

  > 如果设置了高度和宽度，则在加载页面时会保留图像所需的空间。如果没有这些属性，浏览器就不知道图像的大小，也无法为其保留适当的空间，导致页面布局在加载期间发生变化。

* [ ] **避免使用 Base64 图像：** ![medium](https://img.shields.io/badge/-medium-orange) 你可以将微小图像转换为 base64，但实际上并不是最佳实践。

  - 📖 [Base64 Encoding & Performance, Part 1 and 2 by Harry Roberts](https://csswizardry.com/2017/02/base64-encoding-and-performance/)
  - 📖 [A closer look at Base64 image performance – The Page Not Found Blog](http://www.andygup.net/a-closer-look-at-base64-image-performance/)
  - 📖 [When to base64 encode images (and when not to) | David Calhoun](https://www.davidbcalhoun.com/2011/when-to-base64-encode-images-and-when-not-to/)
  - 📖 [Base64 encoding images for faster pages | Performance and seo factors](https://varvy.com/pagespeed/base64-images.html)

* [ ] **懒加载：** ![medium](https://img.shields.io/badge/-medium-orange) 图像懒加载（始终提供 noscript 作为后备方案）。

  _为什么：_

  > 它能改善当前页面的响应时间，避免加载一些用户可能不需要或不必要的图像。

  _怎么做：_

  > 使用[Lighthouse](https://developers.google.com/web/tools/lighthouse/)可以识别当前屏幕外的图像数量。
  > 要确保图片懒加载时鼠标悬停或其他用户操作时显示的替代图像。
  > 可以使用以下图像懒加载的 JavaScript 插件。

  - 🛠 [verlok/lazyload: Github](https://github.com/verlok/lazyload)
  - 📖 [Lazy Loading Images and Video  |  Web Fundamentals  |  Google Developers](https://developers.google.com/web/fundamentals/performance/lazy-loading-guidance/images-and-video/)
  - 📖 [5 Brilliant Ways to Lazy Load Images For Faster Page Loads - Dynamic Drive Blog](http://blog.dynamicdrive.com/5-brilliant-ways-to-lazy-load-images-for-faster-page-loads/)

* [ ] **响应式图像：** ![medium](https://img.shields.io/badge/-medium-orange) 确保提供接近设备显示尺寸的图像。

  _为什么：_

  > 小型设备不需要比视口大的图像。建议在不同尺寸上使用一个图像的多个版本。

  _怎么做：_

  > 为不同的设备设置不同大小的图像。
  > 使用 srcset 和 picture 为每个图像提供多种变体（variants）。

  - 📖 [Responsive images - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images)

**[⬆ 返回顶部](#table-of-contents)**

### JavaScript

![javascript](/javascript.png)

- [ ] **JS 压缩:** ![high](https://img.shields.io/badge/-high-red) 所有 JavaScript 文件都要被压缩，生产环境中删除注释、空格和空行（在 HTTP/2 仍然有效果）。

  _为什么：_

  > 删除所有不必要的空格、注释和空行将减少 JavaScript 文件的大小，并加快网站的页面加载时间，提升用户体验。

  _怎么做：_

  > 建议使用下面的工具在构建或部署之前自动缩小文件。

  - 📖 [uglify-js - npm](https://www.npmjs.com/package/uglify-js)
  - 🛠 [Online JavaScript Compressor](http://refresh-sf.com)
  - 📖 [Short read: How is HTTP/2 different? Should we still minify and concatenate?](https://scaleyourcode.com/blog/article/28)

* [ ] **不内嵌 JavaScript:** ![medium](https://img.shields.io/badge/-medium-orange) _(仅对网站有效)_ 避免在`body`中间嵌入多个 JavaScript 代码，将 JavaScript 代码重新集中到外部文件中，放在`<head>`或页面末尾（`</body>`之前）。

  _为什么：_

  > 将 JavaScript 嵌入代码直接放在`<body>`中可能会降低页面速度，因为它在构建 DOM 时会加载。最好的选择是使用`async` 或 `defer`的外部文件来避免阻塞 DOM 渲染。另一种选择是在`<head>`中放置一些脚本。大多数时候是需要在 DOM 进入主处理之前加载的分析代码或小脚本。

  _怎么做：_

  > 确保使用 async 或 defer 加载所有 script 文件，并准确地在`<head>`中加载代码。

  - 📖 [优化 JavaScript 并提高网站加载速度的 11 个技巧](https://www.upwork.com/hiring/development/11-tips-to-optimize-javascript-and-improve-website-loading-speeds/)

* [ ] **非阻塞 JavaScript：** ![high](https://img.shields.io/badge/-high-red) 使用 defer 属性或使用 async 来异步加载 JavaScript 文件。

  ```html
  <!-- Defer Attribute -->
  <script defer src="foo.js">

  <!-- Async Attribute -->
  <script async src="foo.js">
  ```

  _为什么：_

  > JavaScript 阻止 HTML 文档的正常解析，因此当解析器到达`<script>`标记时（特别是在`<head>`内），它会停止解析并且执行脚本。如果您的脚本位于页面顶部，则强烈建议添加`async`和`defer`，但如果在`</body>`标记之前加载，没有太大影响。但是，使用这些属性来避免性能问题是一种很好的做法。

  _怎么做：_

  > 添加`async`（如果脚本不依赖于其他脚本）或`defer`（如果脚本依赖或依赖于异步脚本）作为 script 脚本标记的属性。
  > 如果有小脚本，可以在异步脚本上方使用内联脚本。

  - 📖 [Remove Render-Blocking JavaScript](https://developers.google.com/speed/docs/insights/BlockingJS)
  - 📖 [Defer loading JavaScript](https://varvy.com/pagespeed/defer-loading-javascript.html)

* [ ] **优化和更新的 JS 库：** ![medium](https://img.shields.io/badge/-medium-orange) 项目中使用的所有 JavaScript 库都是有用到的 (推荐使用原生 JS 的简单功能)并更新到最新版本

  _为什么：_

  > 大多数情况下，新版本都带有优化和安全性修复，所以应该使用最优化的代码来优化项目。确保不存在过时插件。

  _怎么做：_

  > 如果项目使用 NPM 管理依赖包，[npm-check](https://www.npmjs.com/package/npm-check)是一个非常有用的库来升级/更新你的库。

  - 📖 [You may not need jQuery](http://youmightnotneedjquery.com/)
  - 📖 [Vanilla JavaScript for building powerful web applications](https://plainjs.com/)

- [ ] **检查依赖项大小限制：** ![low](https://img.shields.io/badge/-low-green) 确保使用最优的外部库，大多数情况下，可以使用更轻的库来实现相同的功能。

  _为什么：_

  > 你可能想使用 npm 中 745 000 个包中的一个，但你需要选择最适合项目需求的包。例如，MomentJS 是一个很棒的库，但是你可能永远不会使用其中的很多方法，这就是为什么创建 Day.js 的原因。瞬间大小从 16.4kB 到 2kB。


    *怎么做：*
    > 始终比较并选择最适合您需求的轻型库。您还可以使用[npm trends](http://www.npmtrends.com/)等工具来比较NPM包下载次数或[Bundlephobia](https://bundlephobia.com/)以了解依赖项的大小。

    * 🛠 [ai/size-limit: Prevent JS libraries bloat. If you accidentally add a massive dependency, Size Limit will throw an error.](https://github.com/ai/size-limit)
    * 📖 [webpack-bundle-analyzer - npm](https://www.npmjs.com/package/webpack-bundle-analyzer)
    * 📖 [Size Limit: Make the Web lighter — Martian Chronicles, Evil Martians’ team blog](https://evilmartians.com/chronicles/size-limit-make-the-web-lighter)

- [ ] **JavaScript 分析:** ![medium](https://img.shields.io/badge/-medium-orange) 检查 JavaScript 文件（以及 CSS）中的性能问题。

  _为什么：_

  > JavaScript 复杂性可能会降低运行时性能。识别这些可能的问题对提供流畅的用户体验来说至关重要。

  _怎么做：_

  > 使用 Chrome 开发者工具中的时间轴工具来评估脚本事件，并找到可能需要花费太多时间的事件。

  - 📖 [Speed Up JavaScript Execution  |  Tools for Web Developers  |  Google Developers](https://developers.google.com/web/tools/chrome-devtools/rendering-tools/js-execution)
  - 📖 [JavaScript Profiling With The Chrome Developer Tools — Smashing Magazine](https://www.smashingmagazine.com/2012/06/javascript-profiling-chrome-developer-tools/)
  - 📖 [How to Record Heap Snapshots  |  Tools for Web Developers  |  Google Developers](https://developers.google.com/web/tools/chrome-devtools/memory-problems/heap-snapshots)
  - 📖 [Chapter 22 - Profiling the Frontend - Blackfire](https://blackfire.io/docs/book/22-frontend-profiling)
  - 📖 [30 Tips To Improve Javascript Performance](http://www.monitis.com/blog/30-tips-to-improve-javascript-performance/)

* [ ] **Use of Service Workers:** ![medium](https://img.shields.io/badge/-medium-orange) You are using Service Workers in your PWA to cache datas or execute possible heavy tasks without impacting the user experience of your application.
  - 📖 [Service Workers: an Introduction  |  Web Fundamentals  |  Google Developers](https://developers.google.com/web/fundamentals/primers/service-workers/)
  - 📖 [Measuring the Real-world Performance Impact of Service Workers  |  Web  |  Google Developers](https://developers.google.com/web/showcase/2016/service-worker-perf)
  - 📖 [What Are Service Workers and How They Help Improve Performance](https://www.keycdn.com/blog/service-workers/)
  - 📖 [How does a service worker work? - YouTube](https://www.youtube.com/watch?v=__xAtWgfzvc)

- [ ] **使用 tree shaking 技术减少 js 大小:** ![high](https://img.shields.io/badge/-high-red) 通过构建工具分析 JavaScript 代码并移除生产环境中用不到的 js 模块或方法

      * 📖 [

  Reduce JavaScript Payloads with Tree Shaking](https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking/)

- [ ] **使用 code splitting 分包加载 js:** ![high](https://img.shields.io/badge/-high-red) 通过分包加载，减少首次加载所需时间

  _怎么做：_

  > - **Vendor splitting** 根据库文件拆分模块，例如 React 或 lodash 单独打包成一个文件
  > - **Entry point splitting** 根据入口拆分模块，例如通过多页应用入口或者单页应用路由进行拆分
  > - **Dynamic splitting** 根据动态加载拆分模块，使用动态加载语法 `import()` ，实现模块按需加载

  - 📖 [Reduce JavaScript Payloads with Tree Shaking](https://developers.google.com/web/fundamentals/performance/optimizing-javascript/code-splitting/)

**[⬆ 返回顶部](#table-of-contents)**

### Server

![server-side](/server-side.png)

- [ ] **网站使用 HTTPS:** ![high](https://img.shields.io/badge/-high-red)

  _Why:_

  > HTTPS 不仅适用于电子商务网站，也适用于所有存在数据传递的网站。如今的现代浏览器对于不安全的网站在许多功能上做了些限制。 例如：如果网站未使用 HTTPS，则地理定位，推送通知和服务工作程序等功能会不起作用。今天设置和使用 SSL 证书比以前容易得多([Let's Encrypt](https://letsencrypt.org/)能提供免费的 https 服务).

  - 📖 [Why Use HTTPS? | Cloudflare](https://www.cloudflare.com/learning/security/why-use-https/)
  - 📖 [Enabling HTTPS Without Sacrificing Your Web Performance - Moz](https://moz.com/blog/enabling-https-without-sacrificing-web-performance)
  - 📖 [How HTTPS Affects Website Performance](https://wp-rocket.me/blog/https-affects-website-performance/)
  - 📖 [HTTP versus HTTPS versus HTTP2 - The real story | Tune The Web](https://www.tunetheweb.com/blog/http-versus-https-versus-http2/)
  - 📖 [HTTP vs HTTPS — Test them both yourself](https://www.httpvshttps.com/)

- [ ] **页面大小 < 1500 KB(理想 < 500 KB):** ![high](https://img.shields.io/badge/-high-red) (理想情况 < 500 KB) 尽可能减少页面和资源的大小。

  _为什么：_

  > 理想情况下，应该尝试让页面大小<500 KB，但 Web 页面大小中位数大约为 1500 KB（即使在移动设备上）。根据你的目标用户、连接速度、设备，尽可能减少页面大小以尽可能获得最佳用户体验非常重要。

  _怎么做：_

  > 前端性能清单中的所有规则将帮助你尽可能地减少资源和代码。

  - 📖 [Page Weight](https://httparchive.org/reports/page-weight#bytesTotal)
  - 🛠 [What Does My Site Cost?](https://whatdoesmysitecost.com/)

- [ ] **页面加载时间 < 3 秒：** ![high](https://img.shields.io/badge/-high-red) 尽可能减少页面加载时间，以便快速将内容传递给用户。

  _为什么：_

  > 网站或应用程序速度越快，反弹增加的可能性越小，换句话说，失去用户或未来客户的机会就越少。Google 对该主题的充分研究证明了这一点。

  _怎么做：_

  > 使用[Page Speed Insight](https://developers.google.com/speed/pagespeed/insights/)或[WebPageTest](https://www.webpagetest.org/)等在线工具分析可能会降低速度的工具，并使用前端性能清单来缩短加载时间。

  - 🛠 [Compare your mobile site speed](https://www.thinkwithgoogle.com/feature/mobile/)
  - 🛠 [Test Your Mobile Website Speed and Performance - Think With Google](https://testmysite.thinkwithgoogle.com/?_ga=1.155316027.1489996091.1482187369)
  - 📖 [Average Page Load Times for 2018 - How does yours compare? - MachMetrics Speed Blog](https://www.machmetrics.com/speed-blog/average-page-load-times-websites-2018/)

- [ ] **TTFB < 1.3 seconds:** ![high](https://img.shields.io/badge/-high-red) 尽可能减少浏览器在接收数据之前等待的时间。

  - 📖 [什么是 DevTools 中的 TTFB，以及如何处理它](https://scaleyourcode.com/blog/article/27)
  - 📖 [Monitoring your servers with free tools is easy](https://scaleyourcode.com/blog/article/7)
  - 📖 [Time to First Byte (TTFB)](https://varvy.com/pagespeed/ttfb.html)
  - 🛠 [Global latency testing tool](https://latency.apex.sh)

* [ ] **Cookie 大小:** ![medium](https://img.shields.io/badge/-medium-orange) 如果您使用 cookie，请确保每个 cookie 不超过 4096 字节，并且一个域名下不超过 20 个 cookie。

  _为什么：_

  > cookie 存在于 HTTP 头中，在 Web 服务器和浏览器之间交换。保持 cookie 的大小尽可能低是非常重要的，以尽量减少对用户响应时间的影响。

  _怎么做：_

  > 消除不必要的 cookie

  - 📖 [Cookie specification: RFC 6265](https://tools.ietf.org/html/rfc6265)
  - 📖 [Cookies](https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies)
  - 🛠 [Browser Cookie Limits](http://browsercookielimits.squawky.net/)
  - 📖 [Website Performance: Cookies Don't Taste So Good - Monitis Blog](http://www.monitis.com/blog/website-performance-cookies-dont-taste-so-good/)
  - 📖 [Google's Web Performance Best Practices #3: Minimize Request Overhead - GlobalDots Blog](https://www.globaldots.com/googles-web-performance-best-practices-3-minimize-request-overhead/)

- [ ] **最小化 HTTP 请求：** ![high](https://img.shields.io/badge/-high-red) 始终确保所请求的每个文件对网站或应用程序至关重要，尽可能减少 http 请求。

* 📖 [Combine external CSS](https://varvy.com/pagespeed/combine-external-css.html)
* 📖 [Combine external JavaScript](https://varvy.com/pagespeed/combine-external-javascript.html)

- [ ] **使用 CDN 提供静态文件：** ![medium](https://img.shields.io/badge/-medium-orange) 使用 CDN 可以更快地在全球范围内获取到你的静态文件。

* 📖 [10 Tips to Optimize CDN Performance - CDN Planet](https://www.cdnplanet.com/blog/10-tips-optimize-cdn-performance/)
* 📖 [HTTP Caching  |  Web Fundamentals  |  Google Developers](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching)

- [ ] **提供来自相同协议的文件：** ![high](https://img.shields.io/badge/-high-red) 避免网站使用 HTTPS 同时使用 HTTP 来提供相同源地址的文件。

- [ ] **提供可访问的文件：** ![high](https://img.shields.io/badge/-high-red) 避免请求无法访问的文件（404）。

- [ ] **正确设置 HTTP 缓存标头：** ![high](https://img.shields.io/badge/-high-red) 合理设置 HTTP 缓存标头来减少 http 请求次数。

- [ ] **启用 GZIP 压缩** ![high](https://img.shields.io/badge/-high-red)使用压缩方法（如 Gzip 或 Brotli）来减小 JavaScript 文件的大小。使用较小尺寸的文件，用户可以更快地下载资源，从而提高性能。

* 📖 [Check GZIP compression](https://checkgzipcompression.com/)
* 🛠 [Check Brotli Compression](https://tools.keycdn.com/brotli-test)
* 📖 [Can I use... Brotli](https://caniuse.com/#feat=brotli)

- [ ] **分域存放资源：** ![medium](https://img.shields.io/badge/-medium-orange) 由于浏览器同一域名并行下载数有限，利用多域名主机存放静态资源，增加并行下载数，缩短资源加载时间

- [ ] **减少页面重定向** ![high](https://img.shields.io/badge/-high-red)

**[⬆ 返回顶部](#table-of-contents)**

---

### 性能与前端框架

#### Angular

- 📖 [Angular Performance Checklist](https://github.com/mgechev/angular-performance-checklist)

#### React

- 📖 [Optimizing Performance - React](https://reactjs.org/docs/optimizing-performance.html)
- 📖 [React image manipulation | Cloudinary](https://cloudinary.com/documentation/react_image_manipulation)
- 📖 [Debugging React performance with React 16 and Chrome Devtools.](https://building.calibreapp.com/debugging-react-performance-with-react-16-and-chrome-devtools-c90698a522ad)

#### WordPress

- 🛠 [Test Your Website Speed | WordPress Hosting by @WPEngine](https://wpengine.com/speed-tool/)

##### 文章

- 📖 [19 Tips to Speed Up WordPress Performance (Updated)](https://www.wpbeginner.com/wordpress-performance-speed/)
- 📖 [Speed Up Your WordPress - How to Save Images Optimized for Web](https://www.wpbeginner.com/beginners-guide/speed-wordpress-save-images-optimized-web/)

##### 插件推荐

- 🛠 [Caching Plugin for WordPress - Speed up your website with WP Rocket](https://wp-rocket.me/)
- 🛠 [WP-Sweep | WordPress.org](https://wordpress.org/plugins/wp-sweep/)
- 🛠 [Imagify Image Optimizer | WordPress.org](https://wordpress.org/plugins/imagify/)

---

### Translations

The Front-End Performance Checklist wants to also be available in other languages! Don't hesitate to submit your contribution!

- 🇵🇹 Portuguese: [fernandofawkes/Front-End-Performance-Checklist](https://github.com/fernandofawkes/Front-End-Performance-Checklist)
- 🇨🇳 Chinese: [JohnsenZhou/Front-End-Performance-Checklist](https://github.com/JohnsenZhou/Front-End-Performance-Checklist)
- 🇷🇺 Russian: [lex111/Front-End-Performance-Checklist](https://github.com/lex111/Front-End-Performance-Checklist)
- 🇫🇷 French: [WilliamDASILVA/Front-End-Performance-Checklist](https://github.com/WilliamDASILVA/Front-End-Performance-Checklist)
- 🇰🇷 Korean: [ParkSB/Front-End-Performance-Checklist](https://github.com/ParkSB/Front-End-Performance-Checklist)
- 🇪🇸 Spanish: [dagerzuga/Front-End-Performance-Checklist](https://github.com/dagerzuga/Front-End-Performance-Checklist)
- 🇻🇮 Vietnamese : [huynhan147/Front-End-Performance-Checklist](https://github.com/huynhan147/FrontEnd-Performance-Checklist)

## 三、Webpack 优化构建速度

### 3.1、 缩小文件搜索范围

**搜索过程优化包括:**

::: tip

- 优化 resolve.modules 配置
- 优化 resolve.noParse 配置
- 优化 resolve.extensions 配置
- 优化 resolve.noParse 配置
- 优化 优化 Loader 配置

:::

1. **优化 resolve.modules 配置**

   resolve.modules 用于配置 Webpack 去哪些目录下寻找第三方模块。resolve.modules 的默认值是［node modules］，含义是先去当前目录的/node modules 目录下去找我们想找的模块，如果没找到，就去上一级目录../node modules 中找，再没有就去../ .. /node modules 中找，以此类推，这和 Node.js 的模块寻找机制很相似。当安装的第三方模块都放在项目根目录的./node modules 目录下时，就没有必要按照默认的方式去一层层地寻找，可以指明存放第三方模块的绝对路径，以减少寻找。

**优化后的配置**

```js
resolve: {
// 使用绝对路径指明第三方模块存放的位置，以减少搜索步骤
modules: [path.resolve(__dirname,'node_modules')]
},
```

- **设置 resolve.mainFields:['main']，设置尽量少的值可以减少入口文件的搜索步骤**.
  > 第三方模块为了适应不同的使用环境，会定义多个入口文件，mainFields 定义使用第三方模块的哪个入口文件，由于大多数第三方模块都使用 main 字段描述入口文件的位置，所以可以设置单独一个 main 值，减少搜索

2. **优化 resolve.alias 配置**

**对庞大的第三方模块设置 resolve.alias**, 使 webpack 直接使用库的 min 文件，避免库内解析。

```js
 alias: {
  '@': resolve('src'),
},
// 通过以上的配置，引用src底下的common.js文件，就可以直接这么写
import common from '@/common.js';
```

这样会影响 Tree-Shaking，适合对整体性比较强的库使用，如果是像 lodash 这类工具类的比较分散的库，比较适合 Tree-Shaking，避免使用这种方式。

3. **优化 resolve.extensions**

**合理配置 resolve.extensions，减少文件查找**
默认值：extensions:['.js', '.json'],当导入语句没带文件后缀时，Webpack 会根据 extensions 定义的后缀列表进行文件查找，所以：

- **列表值尽量少**
- **频率高的文件类型的后缀写在前面**
- **源码中的导入语句尽可能的写上文件后缀，如 require(./data)要写成 require(./data.json)**

4. `module.noParse`**字段告诉 Webpack 不必解析哪些文件，可以用来排除对非模块化库文件的解析**.

noParse 配置项可以让 Webpack 忽略对部分没采用模块化的文件的递归解析和处理，这 样做的好处是能提高构建性能。原因是一些库如 jQuery、ChartJS 庞大又没有采用模块化标准，让 Webpack 去解析这些文件既耗时又没有意义。
noParse 是可选的配置项，类型需要是 RegExp 、[RegExp]、function 中的一种。例如，若想要忽略 jQuery 、ChartJS ，则优化配置如下：

```js
// 使用正则表达式
noParse: /jquerylchartjs/;
// 使用函数，从 Webpack3.0.0开始支持
noParse: content => {
  // 返回true或false
  return /jquery|chartjs/.test(content);
};
```

5. **优化 loader 配置，通过 test、exclude、include 缩小搜索范围**;

- (1）**优化正则匹配**
- (2）**通过 cacheDirectory 选项开启缓存**
- (3）**通过 include、exclude 来减少被处理的文件**

```js
{
  // 1、如果项目源码中只有js文件，就不要写成/\.jsx?$/，以提升正则表达式的性能
  test: /\.js$/,
  // 2、babel-loader支持缓存转换出的结果，通过cacheDirectory选项开启
  loader: 'babel-loader?cacheDirectory',
  // 3、只对项目根目录下的src 目录中的文件采用 babel-loader
  include: [resolve('src')]
},


```

### 3.2、使用 DllPlugin 减少基础模块编译次数

DllPlugin 动态链接库插件，`其原理是把网页依赖的基础模块抽离出来打包到dll文件中，当需要导入的模块存在于某个dll中时，这个模块不再被打包`，而是去 dll 中获取。**为什么会提升构建速度呢?**原因在于 dll 中大多包含的是常用的第三方模块，如 react、react-dom，所以只要这些模块版本不升级，就只需被编译一次。我认为这样做和配置 resolve.alias 和 module.noParse 的效果有异曲同工的效果。

[详情 demo 请见:lucky_vue_template](https://github.com/MrGaoGang/lucky_vue_template)

1. 使用 DllPlugin 配置一个 webpack.dll.config.js 来构建 dll 文件：

```js
var path = require("path");
var webpack = require("webpack");
var CleanWebpackPlugin = require("clean-webpack-plugin");

var vendor = ["vue", "vuex", "vue-router"];
var vendordev = ["vue/dist/vue.esm.js", "vuex", "vue-router"]; //集成开发版本vue
var config = require("./config/config.js");
module.exports = {
  //你想要打包的模块数组
  entry: {
    vendor: vendor,
    vendordev: vendordev
  },
  output: {
    path: path.join(__dirname, config.dllRoot),
    filename: "[name].dll.js",
    library: "[name]_library"
    //vendor.dll.js 中暴露出的全局变量
    //主要是给DllPlugin中的name 使用
    //故这里需要和webpack.DllPlugin 中的 'name :[name]_libray 保持一致
  },
  plugins: [
    new CleanWebpackPlugin(),
    new webpack.DllPlugin({
      path: path.join(__dirname, config.dllRoot, "[name]-manifest.json"),
      name: "[name]_library",
      context: __dirname
    })
  ]
};
```

> 需要注意 DllPlugin 的参数中 name 值必须和 output.library 值保持一致，并且生成的 manifest 文件中会引用 output.library 值。

2. 在主 config 文件里使用 DllReferencePlugin 插件引入 xxx-manifest.json 文件：

```js
[
  new webpack.DllReferencePlugin({
    context: __dirname,
    manifest: require(config.dllPath(true, true))
  }),

  new HtmlWebpackTagsPlugin({ tags: ["/dll/vendor.dll.js"], append: false }),

  new CopyWebpackPlugin([
    {
      from: path.join(__dirname, config.dllPath(true, false)),
      to: path.join(__dirname, config.dllVendorTarget)
    }
  ])
];
```

### 3.3、使用 externals 减少基础模块编译次数

我们在使用的 js 库如 vue 或者 react 等的时候，webpack 会将它们一起打包，react 和 react-dom 文件就好几百 k，全部打包成一个文件，可想而知，这个文件会很大，用户在首次打开时就往往会出现白屏等待时间过长的问题，这时，我们就需要将这类文件抽离出来。

```js
externals: {
        "react": "React",
        "react-dom": "ReactDOM"
    },
```

这里我们会用到 externals，它和 plugins 是平级。左侧 key 表示依赖，右侧 value 表示文件中使用的对象。比如在 react 开发中，我们常常会这样在文件头部写 import React from 'react'，这里大家可以和上面对号入座下。

> 这里我们就需要对这个文件进行单独的引入使用了，在 index.html 中添加如下代码

```html
<script src="./node_modules/react/umd/react.xxx.js"></script>
<script src="./node_modules/react-dom/umd/react-dom.xxx.js"></script>
```

不过，我们在项目上线的时候不可能会带有 node_modules,所以我们就需要使用一个 copy 插件将 react 和 react-dom 文件复制出来

```js
 new CopyWebpackPlugin([ // from是要copy的文件，to是生成出来的文件
            { from: "node_modules/react/umd/react.xxx.js", to: "js/react.min.js" },
            { from: "node_modules/react-dom/umd/react-dom.xxx.js", to: "js/react-dom.min.js" }
            { from: "public/favicon.ico", to: "favicon.ico" }
        ])
```

### 3.4、使用 HappyPack 多进程解析和处理文件

由于有大量文件需要解析和处理，所以构建是文件读写和计算密集型的操作，特别是当文件数量变多后，Webpack 构建慢的问题会显得更为严重。运行在 Node.之上的 Webpack 是单线程模型的，也就是说 Webpack 需要一个一个地处理任务，不能同时处理多个任务。Happy Pack ( https://github.com/amireh/happypack ）就能让 Webpack 做到这一点，`它将任务分解给多个子进程去并发执行,子进程处理完后再将结果发送给主进`。

**配置如下**

- HappyPack 插件安装：
  `$ npm i -D happypack`

- webpack.base.conf.js 文件对 module.rules 进行配置

```js
    module: {
     rules: [
      {
        test: /\.js$/,
        // 将对.js 文件的处理转交给 id 为 babel 的HappyPack实例
          use:['happypack/loader?id=babel'],
          include: [resolve('src'), resolve('test'),
            resolve('node_modules/webpack-dev-server/client')],
        // 排除第三方插件
          exclude:path.resolve(__dirname,'node_modules'),
        },
        {
          test: /\.vue$/,
          use: ['happypack/loader?id=vue'],
        },
      ]
    },
```

- （3）webpack.prod.conf.js 文件进行配置

```js
const HappyPack = require("happypack");
// 构造出共享进程池，在进程池中包含5个子进程
const HappyPackThreadPool = HappyPack.ThreadPool({ size: 5 });
plugins: [
  new HappyPack({
    // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件
    id: "vue",
    loaders: [
      {
        loader: "vue-loader",
        options: vueLoaderConfig
      }
    ],
    threadPool: HappyPackThreadPool
  }),

  new HappyPack({
    // 用唯一的标识符id，来代表当前的HappyPack是用来处理一类特定的文件
    id: "babel",
    // 如何处理.js文件，用法和Loader配置中一样
    loaders: ["babel-loader?cacheDirectory"],
    threadPool: HappyPackThreadPool
  })
];
```

### 3.5、 使用 ParallelUglifyPlugin 开启多进程压缩 JS 文件

由于压缩 JavaScript 代码时，需要先将代码解析成用 Object 抽象表示的 AST 语法树，再去应用各种规则分析和处理 AST ，所以导致这个过程的计算量巨大，耗时非常多。当 Webpack 有多个 JavaScript 文件需要输出和压缩时，原本会使用 UglifyJS 去一个一个压缩再输出，但是 ParallelUglifyPlugin 会开启多个子进程，将对多个文件的压缩工作分配给多个子进程去完成，每个子进程其实还是通过 UglifyJS 去压缩代码，但是变成了并行执行。所以 ParallelUglify Plugin 能更快地完成对多个文件的压缩工作。

```js
（1）ParallelUglifyPlugin插件安装：
     $ npm i -D webpack-parallel-uglify-plugin
（2）webpack.prod.conf.js 文件进行配置
    const ParallelUglifyPlugin =require('webpack-parallel-uglify-plugin');
    plugins: [
    new ParallelUglifyPlugin({
      cacheDir: '.cache/',
      uglifyJs:{
        compress: {
          warnings: false
        },
        sourceMap: true
      }
     }),
    ]


```

### 3.6、使用自动刷新

借助自动化的手段，在监听到本地源码文件发生变化时，自动重新构建出可运行的代码后再控制浏览器刷新。Webpack 将这些功能都内置了，并且提供了多种方案供我们选择。

Webpack 可以使用两种方式开启监听：

1. 启动 webpack 时加上--watch 参数；
2. 在配置文件中设置 watch:true

**Webpack 配置**
[官方文档点击这里](https://www.webpackjs.com/configuration/watch/)

```js
module.exports = {
  watch: true,
  watchOptions: {
    ignored: /node_modules/,
    aggregateTimeout: 300, //文件变动后多久发起构建，越大越好
    poll: 1000 //每秒询问次数，越小越好
  }
};
```

**相关优化措施：**

- (1）配置忽略一些不监听的一些文件，如：node_modules。
- (2）watchOptions.aggregateTirneout 的值越大性能越好，因为这能降低重新构建的频率。
- (3）watchOptions.poll 的值越小越好，因为这能降低检查的频率。

**Vue Cli 可配置如下：**

```js
devServer: {
  watchOptions: {
    // 不监听的文件或文件夹，支持正则匹配
    ignored: /node_modules/,
    // 监听到变化后等300ms再去执行动作
    aggregateTimeout: 300,
    // 默认每秒询问1000次
    poll: 1000
  }
},


```

### 3.7、开启模块热替换

模块热替换不刷新整个网页而只重新编译发生变化的模块，并用新模块替换老模块，所以预览反应更快，等待时间更少，同时不刷新页面能保留当前网页的运行状态。原理也是向每一个 chunk 中注入代理客户端来连接 DevServer 和网页。开启方式：

- **webpack-dev-server --hot**
- **使用 HotModuleReplacementPlugin，比较麻烦**

`开启后如果修改子模块就可以实现局部刷新，但如果修改的是根JS文件，会整页刷新`，原因在于，子模块更新时，事件一层层向上传递，直到某层的文件接收了当前变化的模块，然后执行回调函数。如果一层层向外抛直到最外层都没有文件接收，就会刷新整页。
使用 `NamedModulesPlugin 可以使控制台打印出被替换的模块的名称而非数字ID`，另外同 webpack 监听，`忽略node_modules目录的文件可以提升性能`。

```js
devServer: {
  hot: true,
},
plugins: [
  new webpack.HotModuleReplacementPlugin(),
// 显示被替换模块的名称
  new webpack.NamedModulesPlugin(), // HMR shows correct file names
]


```

## 四、优化输出质量-压缩文件体积

### 4.1、区分环境--减小生产环境代码体积

代码运行环境分为开发环境和生产环境，代码需要根据不同环境做不同的操作，许多第三方库中也有大量的根据开发环境判断的 if else 代码，构建也需要根据不同环境输出不同的代码，所以需要一套机制可以在源码中区分环境，区分环境之后可以使输出的生产环境的代码体积减小。

环境配置：

```js
//生产环境
mode: "pruduction";
//测试环境
mode: "development";
```

代码使用：

```js
if (process.env.NODE_ENV === "production") {
  console.log("你在生产环境");
  doSth();
} else {
  console.log("你在开发环境");
  doSthElse();
}
```

### 4.2、压缩代码-JS、ES、CSS

1. 压缩 js

   > webpack4 已经默认开启代码压缩。

2. 压缩 ES6：第三方 UglifyJS 插件

随着越来越多的浏览器支持直接执行 ES6 代码，应尽可能的运行原生 ES6，这样比起转换后的 ES5 代码，代码量更少，且 ES6 代码性能更好。直接运行 ES6 代码时，也需要代码压缩，第三方的`uglify-webpack-plugin`提供了压缩 ES6 代码的功能。

**另外要防止 babel-loader 转换 ES6 代码，要在.babelrc 中去掉 babel-preset-env，因为正是 babel-preset-env 负责把 ES6 转换为 ES5。**

```js
npm i -D uglify-webpack-plugin@beta //要使用最新版本的插件
//webpack.config.json
const UglifyESPlugin = require('uglify-webpack-plugin');
//...
plugins:[
    new UglifyESPlugin({
        uglifyOptions: {  //比UglifyJS多嵌套一层
            compress: {
                warnings: false,
                drop_console: true,
                collapse_vars: true,
                reduce_vars: true
            },
            output: {
                beautify: false,
                comments: false
            }
        }
    })
]

```

### 4.3、压缩 CSS：css-loader?minimize、PurifyCSSPlugin

snano 基于 PostCSS，不仅是删掉空格，还能理解代码含义，例如把`color:#ff0000` 转换成 `color:red`，css-loader 内置了 cssnano，只需要使用 `css-loader?minimize` 就可以开启 cssnano 压缩。
另外一种压缩 CSS 的方式是使用[PurifyCSSPlugin](https://github.com/webpack-contrib/purifycss-webpack)，需要配合 `extract-text-webpack-plugin` 使用，它主要的作用是可以去除没有用到的 CSS 代码，类似 JS 的 Tree Shaking。

### 4.4、压缩图片

在 vue 项目中除了可以在 webpack.base.conf.js 中 `url-loader` 中设置 limit 大小来对图片处理，`对小于 limit 的图片转化为 base64 格式`，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 `image-webpack-loader` 来压缩图片：

- （1）首先，安装 image-webpack-loader ：

```bash
npm install image-webpack-loader --save-dev

```

- (2) 然后，在 webpack.base.conf.js 中进行配置：

```js
{
  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
  use:[
    {
    loader: 'url-loader',
    options: {
      limit: 10000,
      name: utils.assetsPath('img/[name].[hash:7].[ext]')
      }
    },
    {
      loader: 'image-webpack-loader',
      options: {
        bypassOnDebug: true,
      }
    }
  ]
}

```

### 4.5、开启 gzip 压缩

gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE 等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右

以下我们以服务端使用我们熟悉的 express 为例，开启 gzip 非常简单，相关步骤如下：

- 安装

```bash
npm install compression --save
```

- 添加代码逻辑：

```js
var compression = require("compression");
var app = express();
app.use(compression());
```

- 重启服务，观察网络面板里面的 response header，如果看到如下红圈里的字段则表明 gzip 开启成功
  ![](https://user-gold-cdn.xitu.io/2019/8/15/16c924653ef48d24?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### 4.6、使用 Tree Shaking 剔除 JS 死代码

ree Shaking 可以剔除用不上的死代码，它依赖 ES6 的 import、export 的模块化语法，最先在 Rollup 中出现，Webpack 2.0 将其引入。适合用于 Lodash、utils.js 等工具类较分散的文件。`它正常工作的前提是代码必须采用ES6的模块化语法，因为ES6模块化语法是静态的（在导入、导出语句中的路径必须是静态字符串，且不能放入其他代码块中`。如果采用了 ES5 中的模块化，例如 module.export = {...}、require( x+y )、if (x) { require( './util' ) }，则 Webpack 无法分析出可以剔除哪些代码。

**启用 Tree Shaking：**

- 修改.babelrc 以保留 ES6 模块化语句：

```json
{
  "presets": [
    [
      "env",
      { "module": false } //关闭Babel的模块转换功能，保留ES6模块化语法
    ]
  ]
}
```

- 启动 webpack 时带上 --display-used-exports 可以在 shell 打印出关于代码剔除的提示

- 使用 UglifyJSPlugin，或者启动时使用--optimize-minimize

- 在使用第三方库时，需要配置 resolve.mainFields: ['jsnext:main', 'main'] 以指明解析第三方库代码时，采用 ES6 模块化的代码入口

## 五、优化输出质量--加速网络请求

### 5.1、提取公共代码

如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：

- 相同的资源被重复加载，浪费用户的流量和服务器的成本。
- 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。

所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack4 内置了 optimization.splitChunks

**提取公共代码方法**

- 1. 将公共代码放置 common 目录
- 2. 安装不同入口文件抽取公共代码
- 3. 抽取不同 ui 框架
- 5. 抽取 webpack 运行资源

webpac 运行资源主要是指：`在浏览器运行时，webpack 用来连接模块化的应用程序的所有代码。runtime 包含：在模块交互时，连接模块所需的加载和解析逻辑。包括浏览器中的已加载模块的连接，以及懒加载模块的执行逻辑。`

[详细配置请见:多页面打包-公共资源抽取实例](https://github.com/MrGaoGang/lucky_vue_template/blob/muti-pages/config/env_config.js)

```js

/**
 * 多入口文件代码分割策略
 */
exports.splitChunks={
  optimization: {
    splitChunks: {
      chunks: "all",
      minSize: 30000,
      minChunks: 1,
      maxAsyncRequests: 5,
      maxInitialRequests: 3,
      automaticNameDelimiter: "-",
      name: true,
      cacheGroups: {
        "vendors-admin": {
          test: /ant-design-vue|@ant-design/, // 抽离ant-design-vue和ant-design
          chunks: "async",//因为采用的是动态加载ui库，所以不使用initial，不使用all是因为可能会导入其他没使用的ant组件代码
          name: "vendors-admin"
        },
        "vendors-index": {
          test: /iview/, // 抽离iview
          chunks: "async",
          name: "vendors-index"
        },
        common: {
          chunks: "initial",//提取admin和index的入口的公共库，通常是vue/vuex/vue-router
          name: "common",
          minChunks: 2,
          maxInitialRequests: 5,
          minSize: 0
        }
      }
    },
    runtimeChunk: {
      name: "manifest"
    }
  }
```

**配置说明**

- minSize(默认是 30000)：形成一个新代码块最小的体积
- minChunks（默认是 1）：在分割之前，这个代码块最小应该被引用的次数（译注：保证代码块复用性，默认配置的策略是不需要多次引用也可以被分割）
- maxInitialRequests（默认是 3）：一个入口最大的并行请求数
- maxAsyncRequests（默认是 5）：按需加载时候最大的并行请求数。
- chunks (默认是 async) ：initial、async 和 all
- test： 用于控制哪些模块被这个缓存组匹配到。原封不动传递出去的话，它默认会选择所有的模块。可以传递的值类型：RegExp、String 和 Function
- name(打包的 chunks 的名字)：字符串或者函数(函数可以根据条件自定义名字)
- priority ：缓存组打包的先后优先级。

打包之后分析:

![](https://github.com/MrGaoGang/lucky_vue_template/raw/muti-pages/images/bundle.png)

### 5.2、代码分割及按需加载代码

通过 vue 写的单页应用时，可能会有很多的路由引入。当打包构建的时候，javascript 包会变得非常大，影响加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来

```js
const Foo = () => import(/* webpackChunkName:"Foo" */ "./Foo.vue");
const router = new VueRouter({
  routes: [{ path: "/foo", component: Foo }]
});
```

**对于常用的 iview/ant-design 等 ui 库需要做到组件的按需加载：**
(常常配合@babel/plugin-syntax-dynamic-import 使用)

```js
//babel.config.js
module.exports = {
  presets: [
    [
      "@babel/preset-env",
      {
        targets: {
          browsers: ["last 3 versions", "ie>=9"]
        },
        useBuiltIns: "entry",
        debug: false
      }
    ]
  ],
  plugins: [
    "@babel/plugin-transform-runtime",
    "@babel/plugin-syntax-dynamic-import",
    "@babel/plugin-proposal-object-rest-spread",
    "transform-vue-jsx",
    [
      "import",
      {
        libraryName: "iview",
        libraryDirectory: "src/components"
      }
    ]
  ]
};
```

### 5.3、提取 css 为一个文件

上面讲述了将 Js 代码做分离，但是这里建议将 css 抽取为一个文件，是为了减少浏览器对服务的请求。众所周知浏览器并发数量通常为 4-6 个。
抽取 css 通常有两种插件方式。

- extract-text-webpack-plugin
- [mini-css-extract-plugin](https://github.com/webpack-contrib/mini-css-extract-plugin)

extract-text-webpack-plugin 对 webpack4.0+支持不太友好，如需要配置，请见[Vue 单/多入口脚手架](https://github.com/MrGaoGang/lucky_vue_template)

**此处简单介绍 mini-css-extract-plugin 的使用方式**

```bash
npm install -D mini-css-extract-plugin
```

```js
// webpack.config.js
var MiniCssExtractPlugin = require("mini-css-extract-plugin");

module.exports = {
  // 其它选项...
  module: {
    rules: [
      // ... 忽略其它规则
      {
        test: /\.css$/,
        use: [
          //测试环境不压缩css,只有生产环境压缩
          process.env.NODE_ENV !== "production" ? "vue-style-loader" : MiniCssExtractPlugin.loader,
          "css-loader"
        ]
      }
    ]
  },
  plugins: [
    // ... 忽略 vue-loader 插件
    new MiniCssExtractPlugin({
      filename: "style.css"
    })
  ]
};
```

### 5.4、使用 CDN 加速静态资源加载

**1. CDN 缓存介绍**
由于 CDN 会为资源开启长时间的缓存，例如用户从 CDN 上获取了 index.html，即使之后替换了 CDN 上的 index.html，用户那边仍会在使用之前的版本直到缓存时间过期。业界做法：

- HTML 文件：`放在自己的服务器上且关闭缓存，不接入CDN`;
- 静态的 JS、CSS、图片等资源：**开启 CDN 和缓存，同时文件名带上由内容计算出的 Hash 值，这样只要内容变化 hash 就会变化，文件名就会变化，就会被重新下载而不论缓存时间多长。**

::: tip

另外，HTTP1.x 版本的协议下，浏览器会对于向同一域名并行发起的请求数限制在`4~8个`。那么把所有静态资源放在同一域名下的 CDN 服务上就会遇到这种限制，所以可以把他们分散放在不同的 CDN 服务上，例如 JS 文件放在 js.cdn.com 下，将 CSS 文件放在 css.cdn.com 下等。这样又会带来一个新的问题：增加了域名解析时间，这个可以通过 dns-prefetch 来解决 `<link rel='dns-prefetch' href='//js.cdn.com'>`来缩减域名解析的时间。
:::

**2. 构建需要满足的条件**

- 静态资源导入的 URL 要变成指向 CDN 服务的绝对路径的 URL
- 静态资源的文件名需要带上根据内容计算出的 Hash 值
- 不同类型资源放在不同域名的 CDN 上

**3. 配置参考**

```js
const ExtractTextPlugin = require('extract-text-webpack-plugin');
const {WebPlugin} = require('web-webpack-plugin');
//...
output:{
 filename: '[name]_[chunkhash:8].js',
 path: path.resolve(__dirname, 'dist'),
 publicPatch: '//js.cdn.com/id/', //指定存放JS文件的CDN地址
},
module:{
 rules:[{
     test: /\.css/,
     use: ExtractTextPlugin.extract({
         use: ['css-loader?minimize'],
         publicPatch: '//img.cdn.com/id/', //指定css文件中导入的图片等资源存放的cdn地址
     }),
 },{
    test: /\.png/,
    use: ['file-loader?name=[name]_[hash:8].[ext]'], //为输出的PNG文件名加上Hash值
 }]
},
plugins:[
  new WebPlugin({
     template: './template.html',
     filename: 'index.html',
     stylePublicPath: '//css.cdn.com/id/', //指定存放CSS文件的CDN地址
  }),
 new ExtractTextPlugin({
     filename:`[name]_[contenthash:8].css`, //为输出的CSS文件加上Hash
 })
]


```

**4. 构建注意事项**

- 设置了 Js/css 资源放在 cdn 上，会存在**资源相对路径无法访问问题**，

比如说：在 vue 中使用相对路径`../css/infor.css`,在编译完成之后，生产环境访问时时无法使用`//css.cdn.com/id/css/infor.css`访问到的。
此时解决办法:

::: tip
使用`set-webpack-public-path plugin for webpack`,解决相对路径问题。详细文档请见:[这里 set-webpack-public-path plugin for webpack](https://github.com/microsoft/web-build-tools/blob/master/webpack/set-webpack-public-path-plugin/README.md)
:::

### 5.5、添加浏览器缓存

[你应该知道的缓存](https://juejin.im/post/5ae081aaf265da0b767d263a)

缓存主要分为：`强缓存和协商缓存`

- 强缓存：主要是通过 http 请求头中的`Cache-Control`和`Expire`两个字段控制。Expire 是 HTTP1.0 标准下的字段，在这里我们可以忽略。我们重点来讨论的 Cache-Control 这个字段。

一般，我们会设置 Cache-Control 的值为`“public, max-age=xxx”`，表示在 xxx 秒内再次访问该资源，均使用本地的缓存，不再向服务器发起请求。

- 协商缓存：HTTP 的条件方法可以高效的实现再验证。HTTP 允许缓存向原始服务器发送一个条件 GET,请求服务器只有在文档与缓存中现有的副本不同时,才回送对象主体,对于缓存在验证来说最有用的 2 个首部时

  - `If-Modified-Since: <date>`:

  如果从指定日期之后,文档被修改了,就执行请求的方法。可以与 Last-Modfied 服务器响应首部配合使用,只有在内容修改后与已缓存版本有所不同的时候才去获取内容

  - `If-None-Match:<tags>`:

  服务器可以为文档提供特殊的标签(ETag),而不是将其与最近修改日期向匹配,这些标签就像序列号一样。如果已缓存标签与服务器文档中的标签有所不同,If-None-Match 首部就会执行所请求的方法

> 在更新版本之后，如何让用户第一时间使用最新的资源文件呢？在更新版本的时候，顺便把静态资源的路径改了，这样，就相当于第一次访问这些资源，就不会存在缓存的问题了。

**webpack 使用 Hash 方式,**

```js
entry:{
    main: path.join(__dirname,'./main.js'),
    vendor: ['react', 'antd']
},
output:{
    path:path.join(__dirname,'./dist'),
    publicPath: '/dist/',
    filname: 'bundle.[chunkhash].js'
}

```

webpack 给我们提供了三种哈希值计算方式，分别是`hash、chunkhash和contenthash`。那么这三者有什么区别呢？

- hash：**跟整个项目的构建相关，构建生成的文件 hash 值都是一样的，只要项目里有文件更改，整个项目构建的 hash 值都会更改。**
- chunkhash：**根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的 hash 值。**
- contenthash：**由文件内容产生的 hash 值，内容不同产生的 contenthash 值也不一样。**

::: tip
在实际在项目中，我们一般会把项目中的 css 都抽离出对应的 css 文件来加以引用。如果我们使用 chunkhash，当我们改了 css 代码之后，会发现 css 文件 hash 值改变的同时，js 文件的 hash 值也会改变。这时候，contenthash 就派上用场了。

结合上面的各种优化方案，浏览器缓存方案为：

1. **提取公共代码(vue/react/jquery 等)或者使用 external/dllplugin 方式，进行抽取，减少基础模块编译次数，从而减少浏览器访问次数(静态资源不变，浏览器使用缓存读取基础模块)；**
2. **css 文件和 Js 文件采用 contenthash/chunkhash，减少文件 hash 值变动**
3. **设置 Cache-Control，控制缓存时间**

:::

### 5.6、 页面预加载 preload

详情请见：[页面预加载 preload](../deep/页面预加载.md);

## 六、优化结果分析

### 6.1、优化 SourceMap

我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩，去掉多余的空格，且 babel 编译化后，最终会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug 的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发不好调式，因此 sourceMap 出现了，`它就是为了解决不好调式代码问题的`。

[官方文档](https://www.webpackjs.com/configuration/devtool/)

**SourceMap 的可选值如下：**

| devtool                        | 构建速度 | 重新构建速度 | 生产环境 | 品质(quality)          |
| ------------------------------ | -------- | ------------ | -------- | ---------------------- |
| (none)                         | +++      | +++          | yes      | 打包后的代码           |
| eval                           | +++      | +++          | no       | 生成后的代码           |
| cheap-eval-source-map          | +        | ++           | no       | 转换过的代码（仅限行） |
| cheap-module-eval-source-map   | o        | ++           | no       | 原始源代码（仅限行）   |
| eval-source-map                | --       | +            | no       | 原始源代码             |
| cheap-source-map               | +        | o            | yes      | 转换过的代码（仅限行） |
| cheap-module-source-map        | o        | -            | yes      | 原始源代码（仅限行）   |
| inline-cheap-source-map        | +        | o            | no       | 转换过的代码（仅限行） |
| inline-cheap-module-source-map | o        | -            | no       | 原始源代码（仅限行）   |
| source-map                     | --       | --           | yes      | 原始源代码             |
| inline-source-map              | --       | --           | no       | 原始源代码             |
| hidden-source-map              | --       | --           | yes      | 原始源代码             |
| nosources-source-map           | --       | --           | yes      | 无源代码内容           |

::: tip
`+++` 非常快速, `++` 快速, `+` 比较快, `o` 中等, `-` 比较慢, `--` 慢
:::

**对于开发环境**

以下选项非常适合开发环境：

`eval` - 每个模块都使用 `eval()` 执行，并且都有 `//@ sourceURL`。此选项会非常快地构建。主要缺点是，由于会映射到转换后的代码，而不是映射到原始代码（没有从 loader 中获取 source map），所以不能正确的显示行数。

`eval-source-map` - 每个模块使用 `eval()` 执行，并且 source map 转换为 DataUrl 后添加到 `eval()` 中。初始化 source map 时比较慢，但是会在重新构建时提供比较快的速度，并且生成实际的文件。行数能够正确映射，因为会映射到原始代码中。它会生成用于开发环境的最佳品质的 source map。

`cheap-eval-source-map` - 类似 `eval-source-map`，每个模块使用 `eval()` 执行。这是 "cheap(低开销)" 的 source map，因为它没有生成列映射(column mapping)，只是映射行数。它会忽略源自 loader 的 source map，并且仅显示转译后的代码，就像 `eval` devtool。

`cheap-module-eval-source-map` - 类似 `cheap-eval-source-map`，并且，在这种情况下，源自 loader 的 source map 会得到更好的处理结果。然而，loader source map 会被简化为每行一个映射(mapping)。

**对于生产环境**

这些选项通常用于生产环境中：

`(none)`（省略 `devtool` 选项） - 不生成 source map。这是一个不错的选择。

`source-map` - 整个 source map 作为一个单独的文件生成。它为 bundle 添加了一个引用注释，以便开发工具知道在哪里可以找到它。

::: warning
你应该将你的服务器配置为，不允许普通用户访问 source map 文件！
:::

`hidden-source-map` - 与 `source-map` 相同，但不会为 bundle 添加引用注释。如果你只想 source map 映射那些源自错误报告的错误堆栈跟踪信息，但不想为浏览器开发工具暴露你的 source map，这个选项会很有用。

::: warning
你不应将 source map 文件部署到 web 服务器。而是只将其用于错误报告工具。
:::

`nosources-source-map` - 创建的 source map 不包含 `sourcesContent(源代码内容)`。它可以用来映射客户端上的堆栈跟踪，而无须暴露所有的源代码。你可以将 source map 文件部署到 web 服务器。

::: warning
这仍然会暴露反编译后的文件名和结构，但它不会暴露原始代码。
:::

::: tip
在使用 `terser-webpack-plugin` 时，你必须提供 `sourceMap：true` 选项来启用 source map 支持。
:::

### 6.2、使用 webpack-bundle-analyzer

**配置文件配置**

```js
if (config.build.bundleAnalyzerReport) {
  var BundleAnalyzerPlugin =   require('webpack-bundle-analyzer').BundleAnalyzerPlugin;
  webpackConfig.plugins.push(new BundleAnalyzerPlugin());
}
执行 $ npm run build --report 后生成分析报告如下：

```

![](https://github.com/MrGaoGang/lucky_vue_template/raw/muti-pages/images/bundle.png)

### 6.3 使用 Chrome Performance 查找性能瓶颈

使用 Chrome 开发者工具分析页面性能的步骤如下。

- 打开 Chrome 开发者工具，切换到 Performance 面板
- 点击 Record 开始录制
- 刷新页面或展开某个节点
- 点击 Stop 停止录制
  [详情可见：全新 Chrome Devtool Performance 使用指南](https://zhuanlan.zhihu.com/p/29879682)

## 参考

- [Vue 项目性能优化 — 实践指南（网上最全 / 详细）](https://juejin.im/post/5d548b83f265da03ab42471d)
- [Vue 项目 Webpack 优化实践，构建效率提高 50%](https://juejin.im/post/5c1fa158f265da613c09cb36)
- [前端缓存最佳实践](https://juejin.im/post/5c136bd16fb9a049d37efc47)
- [三十分钟掌握 Webpack 性能优化](https://juejin.im/post/5b652b036fb9a04fa01d616b)
- [前端性能优化清单](http://lab.johnsenzhou.com/Front-End-Performance-Checklist/)
