### 判断一个字符在字符串中出现的次数

```js
var s = "jhdoiweesdds";
var n = s.split("dd").length - 1;
console.log(n);
```

### 在 range(m,n)整数中出现 k 的个数

```js
function NumberOf1Between1AndN_Solution(m, n, k) {
  // write code here
  let counts, num;
  counts = 0;
  if (n < 1) {
    return 0;
  }
  for (var i = m; i <= n; i++) {
    num = i;
    while (num > 0) {
      if (num % 10 == k) {
        counts++;
      }
      num = Math.floor(num / 10);
    }
  }
  return counts;
}
console.log("====================================");
console.log(NumberOf1Between1AndN_Solution(0, 9999, 7)); //4000
console.log("====================================");
```

### 字符串/数字向左/右移动 N 位

```js
function shiftLeft(str, n) {
  var len = str.length;
  // 因为是循环移动，所以需要处理移动位数大于字符串长度的情况
  n = n % len;

  return str.substring(n, len) + str.substring(0, n);
}

var s = shiftLeft("123456", 2);
console.log(s); // "cdefgab"

s = shiftLeft("abcdefg", 10);
console.log(s); // "defgabc"
```

### 数组去重

```js
var myArray = ["a", "b", "a", "b", "c", "e", "e", "c", "d", "d", "d", "d"];
var myOrderedArray = myArray.reduce(function(accumulator, currentValue) {
  if (accumulator.indexOf(currentValue) === -1) {
    accumulator.push(currentValue);
  }
  return accumulator;
}, []);

console.log(myOrderedArray);
```

### 两个超长数字相加

```js
function add(a, b) {
  let isAddOne = false; //是否加一
  let nums = "";
  let len = Math.max(a.length, b.length);
  a = a.padStart(len, "0");
  for (let i = len - 1; i >= 0; i--) {
    let temp = 0;
    temp = Number(a[i]) + Number(b[i]);
    isAddOne && temp++;
    isAddOne = temp >= 10;
    nums = (!isAddOne ? temp : temp - 10) + nums + "";
  }
  isAddOne && (nums = 1 + nums);
  return nums;
}
console.log("====================================");
console.log(add("123", "1231"));
console.log("====================================");
```

### 101 个数字，[0，100]中有一个是重复的，找出这个重复的数字

### 对 Number 和 True 的理解

```js
console.log(Number(true)); //1
console.log(Number(null)); //0
console.log(Number(undefined)); //NaN
console.log(typeof NaN); //number
console.log(0.1 + 0.2 == 0.3, 0.5 + 0.1 == 0.6); //false true
console.log(true == 1); //true
console.log(true === 1); //false
```

### 请写出以下结果

```js
fn(); //2
function fn() {
  console.log(1);
}
fn(); //2
var fn = 10;
fn(); //Uncaught TypeError: fn is not a function 到这里，程序终止，不往下执行了
function fn() {
  console.log(2);
}
fn();
```

### 创建一个方法,实现数组的扁平化处理

```js
let givenArr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10];
let outputArr = [1, 2, 2, 3, 4, 5, 5, 6, 7, 8, 9, 11, 12, 12, 13, 14, 10];
```

#### 方法一

```js
function flatten(arr) {
  return arr.reduce(function(prev, item) {
    return prev.concat(Array.isArray(item) ? flatten(item) : item);
  }, []);
}
```

#### 方法二

```js
function flatten(arr){
    while(arr.some(item=>Array.isArray(item)){
        arr = [].concat(...arr);
    }
    return arr;
}
```

### 实现一个 div 滑动的动画，由快至慢 5s 结束（不准用 css3)

```js

.sj{
    width:50px;
    height:50px;
    border:1px solid red;
    position:absolute;
    left:0
}
<div class="sj" id="sj"></div>
//ele为要移动的盒子，target为目标位置（像素），spd为计数器的频率
var ele = document.getElementById('sj')
function animate(ele,spd){
    var start = Date.now(); // remember start time
    var timer = setInterval(function() {
        var timePassed = Date.now() - start;
        var step = Math.ceil(Math.abs(timePassed - 5000)/10)
        console.log(step)
        if (timePassed >= 5000) {
            clearInterval(timer); // finish the animation after 2 seconds
            return;
        }
        ele.style.left = ele.offsetLeft + step + 'px'
    }, spd);
}
```

###  实现一个 div 滑动的动画，由快至慢到 500px 结束

```js
function animate1(ele, target, spd) {
  var timer = setInterval(function() {
    var step = (target - ele.offsetLeft) / 10;
    //对步长进行二次加工(大于0向上取整,小于0向下取整)
    step = step > 0 ? Math.ceil(step) : Math.floor(step);
    //动画原理： 目标位置 = 当前位置 + 步长
    ele.style.left = ele.offsetLeft + step + "px";
    //检测缓动动画有没有停止
    if (Math.abs(target - ele.offsetLeft) <= Math.abs(step)) {
      //处理小数赋值
      ele.style.left = target + "px";
      clearInterval(timer);
    }
  }, spd);
}
```

### 请写出 5 中 CSS 隐藏的方法

```js
opacity: 0
visibility: hidden;
display: none;
position: absoluute
clip-path: polygon(0px 0px,0px 0px,0px 0px, 0px 0px)
```

### 实现一个方法,找出数组中重复的元素

```js
举例;

arr = [1, 2, 3, 4, 1, 1, 2, 4, 4];

输出[(1, 2, 4)];
```

```js
Array.prototype.repeNum = function() {
  let new_arr = this.sort(); //先排序
  let res = [];
  for (let i = 0; i < new_arr.length; i++) {
    if (
      new_arr[i] == new_arr[i + 1] && //判断是否重复,是否已经放入容器
      new_arr[i] != new_arr[i - 1]
    ) {
      res.push(new_arr[i]);
    }
  }
  return res;
};
```

###  将这段英文 this is a pen 首字母大写

```js
法一：
function bigLetter(str){
let newArr = str.split(" ").map((v,i)=>{
  return v.slice(0,1).toUpperCase() + v.slice(1)
})
return newArr.join(" ")
}

法二：
function bigLetter(str){
bigStr = str.toLowerCase().replace(/\b\w+\b/g, function(word){
  return word.substring(0,1).toUpperCase()+word.substring(1);
});
return bigStr;
}
```

### 页面内有一个 input 输入框，实现在数组 arr 查询命中词并要求 autocomplete 效果

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      #div1 {
        margin: 200px auto;
        position: relative;
      }

      ul {
        list-style: none;
        margin: 0 auto;
        background-color: #ededed;
        color: #3b200c;
        width: 400px;
        border: none;
      }

      li {
        cursor: pointer;
      }

      input {
        display: block;
        margin: 0 auto;
        line-height: 40px;
        height: 40px;
        width: 400px;
        font-size: 20px;
        background-color: #ede387;
        border: none;
      }
    </style>
  </head>

  <body>
    <div id="div1">
      <input type="text" id="input" placeholder="有autocomplete的输入框" />
      <ul id="ul"></ul>
    </div>
  </body>
  <script>
    var arr = [
      "a",
      "apple",
      "abandon",
      "bilibili",
      "beep",
      "before",
      "become",
      "being",
      "highmaintains",
      "by",
      "bye",
      "banana"
    ];
    input.addEventListener("input", function(event) {
      var _value = event.target.value.trim();
      if (_value) {
        autoComplete(_value, arr);
      } else {
        ul.innerHTML = "";
      }
    });
    function autoComplete(str, arr) {
      var lis = [];
      arr.forEach(word => {
        if (word.startsWith(str)) {
          lis.push("<li>" + word + "</li>");
        }
      });
      ul.innerHTML = lis.join("");
    }

    function addToInput(li) {
      var _txt = li.innerText;
      input.value = _txt;
    }

    ul.addEventListener("click", function(event) {
      if (event.target.tagName.toLowerCase() === "li") {
        addToInput(event.target);
      }
    });
  </script>
</html>
```

### 有 A、B、C、D 四个人，要在夜里过一座桥

他们通过这座桥分别需要耗时 1、2、5、10 分钟，只有一支手电，并且同时最多只能两个人一起过桥。

请问，如何安排，能够在 17 分钟内这四个人都过桥?

答案：A & B -->2 mins

1 mins <-- A

C & D -->10 mins

2 mins <-- B

A & B --> 2 mins

一共 2 + 1 + 10 + 2 + 2 = 17 mins

### 1-20 的两个数把和告诉 A,积告诉 B，A 说不知道是多少，B 也说不知道，这时 A 说我知道了，B 接着说我也知道了，问这两个数是多少?

答案有 3 个：

2 和 2

2 和 3

2 和 4

### 爸爸,妈妈,妹妹,小强,至少两个人同一生肖的概率是多少?

> 1-12*11*10*9/12*12*12*12 = 1-55/96 = 41/96

### 不使用其他变量，交换两个整型 a，b 的值

x = x+y; y = x-y; x = x-y

### 请从 2017-05-15T09:10:23 Europe/Paris 提取出结果["2017","05","15","09","10","23"]

```js
let str = "2017-05-15T09:10:23 Europe/Paris";
let arr = str.match(/\d{1,}/g);
//match会返回一个数组，
// \d 查找数字
// {1,} 表示至少重复几次
// /g表示全局搜索
```

### Array.indexOf 实现

```js
Array.prototype.indexOf = function(searchElement, fromIndex) {
  "use strict";
  var k;
  if (this == null) {
    throw new TypeError('"this" is null or not defined');
  }
  var o = Object(this);
  var len = o.length;
  if (len === 0) {
    return -1;
  }
  var n = fromIndex > -1 ? fromIndex : 0;

  if (n >= len) {
    return -1;
  }
  k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
  for (; k < len; k++) {
    if (k in o && o[k] === searchElement) return k;
  }
  return -1;
};

let array = new Array();
array.push(1);
array.push(2);

console.log(array.indexOf(2));
```

### 非递归二分查找

```js
function BinarySearch(arr, item) {
  var left = 0,
    right = arr.length - 1;
  while (left <= right) {
    var mid = Math.floor((left + right) / 2);
    if (arr[mid] == item) {
      return mid;
    } else if (arr[mid] > item) {
      right = mid - 1;
    } else {
      left = mid + 1;
    }
  }
  return -1;
}
console.log(BinarySearch([1, 2, 3, 4, 5], 10));
```

### 递归二分查找

```js
function BinarySearch(arr, item, start, end) {
  var mid = Math.floor((start + end) / 2);
  if (start > end) {
    return -1;
  }
  if (item === arr[mid]) {
    return mid;
  } else if (item < arr[mid]) {
    return BinarySearch(arr, item, start, mid - 1);
  } else {
    return BinarySearch(arr, item, mid + 1, end);
  }
}

let array = [1, 2, 3, 4, 5];
console.log(BinarySearch(array, 5, 0, array.length));
```

### 斐波那契数列
**递归方式和尾递归**

```js
/**
 * 递归方式实现
 * @param {*} n 
 */
function FibonacciRecursive(n) {
    if (n < 2)
        return n;
    return (FibonacciRecursive(n - 1) + FibonacciRecursive(n - 2));
}
/**
 * 尾递归
 * @param {*} n 
 * @param {*} ret1 
 * @param {*} ret2 
 */
function FibonacciTailRecursive(n, ret1, ret2) {
    if (n == 0)
        return ret1;
    return FibonacciTailRecursive(n - 1, ret2, ret1 + ret2);
}

let start = Date.now();
console.log(FibonacciRecursive(30));
console.log(Date.now() - start);


let start2 = Date.now();
console.log(FibonacciTailRecursive(30, 0, 1));
console.log(Date.now() - start2);

```
**递归的优化**

```js
var cache = [];
function fib(n) {
    if (cache[n] !== undefined) {
        return cache[n];
    }
    if (n <= 2) {
        cache[n] = 1;
        return 1;
    }
    cache.push(fib(n - 1) + fib(n - 2));
    return cache[n];
}
let start=Date.now();
console.log(fib(30));
console.log(Date.now()-start);

```
